"""
This type stub file was generated by pyright.
"""

"""
Helper functions for working with the underlying system. These are mostly os
dependent, only working on linux, osx, and bsd. In almost all cases they're
best-effort, providing **None** if the lookup fails.

.. versionchanged:: 1.3.0
   Dropped the get_* prefix from several function names. The old names still
   work, but are deprecated aliases.

.. versionchanged:: 1.5.0
   Added the **SYSTEM_CALL_TIME** global, which tracks total time spent making
   system commands.

**Module Overview:**

::

  is_windows - checks if we're running on windows
  is_mac - checks if we're running on a mac
  is_gentoo - checks if we're running on gentoo
  is_slackware - checks if we're running on slackware
  is_bsd - checks if we're running on the bsd family of operating systems

  is_available - determines if a command is available on this system
  is_running - determines if a given process is running
  size_of - provides the memory usage of an object
  call - runs the given system command and provides back the results

  name_by_pid - gets the name for a process by the given pid
  pid_by_name - gets the pid for a process by the given name
  pid_by_port - gets the pid for a process listening to a given port
  pid_by_open_file - gets the pid for the process with an open file
  pids_by_user - provides processes owned by a user
  cwd - provides the current working directory for a given process
  user - provides the user a process is running under
  start_time - provides the unix timestamp when the process started
  tail - provides lines from the end of a file
  bsd_jail_id - provides the BSD jail id a given process is running within
  bsd_jail_path - provides the path of the given BSD jail

  is_tarfile - checks if the given path is a tarball
  expand_path - expands relative paths and ~ entries
  files_with_suffix - provides files with the given suffix

  get_process_name - provides our process' name
  set_process_name - changes our process' name

.. data:: Status (enum)

  State of a subprocess.

  .. versionadded:: 1.6.0

  ====================  ===========
  Status                Description
  ====================  ===========
  PENDING               not yet started
  RUNNING               currently being performed
  DONE                  completed successfully
  FAILED                failed with an exception
  ====================  ===========
"""
State = ...
SIZE_RECURSES = ...
CMD_AVAILABLE_CACHE = ...
SHELL_COMMANDS = ...
IS_RUNNING_PS_LINUX = ...
IS_RUNNING_PS_BSD = ...
GET_NAME_BY_PID_PS = ...
GET_PID_BY_NAME_PGREP = ...
GET_PID_BY_NAME_PIDOF = ...
GET_PID_BY_NAME_PS_LINUX = ...
GET_PID_BY_NAME_PS_BSD = ...
GET_PID_BY_NAME_LSOF = ...
GET_PID_BY_PORT_NETSTAT = ...
GET_PID_BY_PORT_SOCKSTAT = ...
GET_PID_BY_PORT_LSOF = ...
GET_PID_BY_FILE_LSOF = ...
GET_PIDS_BY_USER_LINUX = ...
GET_PIDS_BY_USER_BSD = ...
GET_CWD_PWDX = ...
GET_CWD_LSOF = ...
GET_BSD_JAIL_ID_PS = ...
GET_BSD_JAIL_PATH = ...
BLOCK_SIZE = ...
PR_SET_NAME = ...
argc_t = ...
Py_GetArgcArgv = ...
_PROCESS_NAME = ...
_MAX_NAME_LENGTH = ...
SYSTEM_CALL_TIME = ...
SYSTEM_CALL_TIME_LOCK = ...
class CallError(OSError):
  """
  Error response when making a system call. This is an **OSError** subclass
  with additional information about the process. Depending on the nature of the
  error not all of these attributes will be available.

  :var str msg: exception string
  :var str command: command that was ran
  :var int exit_status: exit code of the process
  :var float runtime: time the command took to run
  :var str stdout: stdout of the process
  :var str stderr: stderr of the process
  """
  def __init__(self, msg, command, exit_status, runtime, stdout, stderr) -> None:
    ...
  
  def __str__(self) -> str:
    ...
  


class CallTimeoutError(CallError):
  """
  Error response when making a system call that has timed out.

  .. versionadded:: 1.6.0

  :var float timeout: time we waited
  """
  def __init__(self, msg, command, exit_status, runtime, stdout, stderr, timeout) -> None:
    ...
  


class DaemonTask:
  """
  Invokes the given function in a subprocess, returning the value.

  .. versionadded:: 1.6.0

  :var function runner: function to be invoked by the subprocess
  :var tuple args: arguments to provide to the subprocess
  :var int priority: subprocess nice priority

  :var stem.util.system.State status: state of the subprocess
  :var float runtime: seconds subprocess took to complete
  :var object result: return value of subprocess if successful
  :var exception error: exception raised by subprocess if it failed
  """
  def __init__(self, runner, args=..., priority=..., start=...) -> None:
    ...
  
  def run(self): # -> None:
    """
    Invokes the task if it hasn't already been started. If it has this is a
    no-op.
    """
    ...
  
  def join(self): # -> Any | None:
    """
    Provides the result of the daemon task. If still running this blocks until
    the task is completed.

    :returns: response of the function we ran

    :raises: exception raised by the function if it failed with one
    """
    ...
  


def is_windows(): # -> bool:
  """
  Checks if we are running on Windows.

  :returns: **bool** to indicate if we're on Windows
  """
  ...

def is_mac(): # -> bool:
  """
  Checks if we are running on Mac OSX.

  :returns: **bool** to indicate if we're on a Mac
  """
  ...

def is_gentoo(): # -> bool:
  """
  Checks if we're running on Gentoo.

  :returns: **bool** to indicate if we're on Gentoo
  """
  ...

def is_slackware(): # -> bool:
  """
  Checks if we are running on a Slackware system.

  :returns: **bool** to indicate if we're on a Slackware system
  """
  ...

def is_bsd(): # -> bool:
  """
  Checks if we are within the BSD family of operating systems. This currently
  recognizes Macs, FreeBSD, and OpenBSD but may be expanded later.

  :returns: **bool** to indicate if we're on a BSD OS
  """
  ...

def is_available(command, cached=...): # -> bool:
  """
  Checks the current PATH to see if a command is available or not. If more
  than one command is present (for instance "ls -a | grep foo") then this
  just checks the first.

  Note that shell (like cd and ulimit) aren't in the PATH so this lookup will
  try to assume that it's available. This only happends for recognized shell
  commands (those in SHELL_COMMANDS).

  :param str command: command to search for
  :param bool cached: makes use of available cached results if **True**

  :returns: **True** if an executable we can use by that name exists in the
    PATH, **False** otherwise
  """
  ...

def is_running(command): # -> bool | None:
  """
  Checks for if a process with a given name or pid is running.

  .. versionchanged:: 1.6.0
     Added support for list and pid arguments.

  :param str,list,int command: process name if a str, multiple process names if
    a list, or pid if an int to be checked

  :returns: **True** if the process is running, **False** if it's not among ps
    results, and **None** if ps can't be queried
  """
  ...

def size_of(obj, exclude=...): # -> int:
  """
  Provides the `approximate memory usage of an object
  <https://code.activestate.com/recipes/577504/>`_. This can recurse tuples,
  lists, deques, dicts, and sets. To teach this function to inspect additional
  object types expand SIZE_RECURSES...

  ::

    stem.util.system.SIZE_RECURSES[SomeClass] = SomeClass.get_elements

  .. versionadded:: 1.6.0

  :param object obj: object to provide the size of
  :param set exclude: object ids to exclude from size estimation

  :returns: **int** with the size of the object in bytes

  :raises: **NotImplementedError** if using PyPy
  """
  ...

def name_by_pid(pid): # -> None:
  """
  Attempts to determine the name a given process is running under (not
  including arguments). This uses...

  ::

    1. Information from /proc
    2. ps -p <pid> -o command

  :param int pid: process id of the process to be queried

  :returns: **str** with the process name, **None** if it can't be determined
  """
  ...

def pid_by_name(process_name, multiple=...):
  """
  Attempts to determine the process id for a running process, using...

  ::

    1. pgrep -x <name>
    2. pidof <name>
    3. ps -o pid -C <name> (linux)
       ps axc | egrep " <name>$" (bsd)
    4. lsof -tc <name>
    5. tasklist | str <name>.exe

  :param str process_name: process name for which to fetch the pid
  :param bool multiple: provides a list of all pids if **True**, otherwise
    results with multiple processes are discarded

  :returns:
    Response depends upon the 'multiple' argument as follows...

    * if **False** then this provides an **int** with the process id or **None** if it can't be determined
    * if **True** then this provides a **list** of all **int** process ids, and an empty list if it can't be determined
  """
  ...

def pid_by_port(port): # -> int | None:
  """
  Attempts to determine the process id for a process with the given port,
  using...

  ::

    1. netstat -npltu | grep 127.0.0.1:<port>
    2. sockstat -4l -P tcp -p <port>
    3. lsof -wnP -iTCP -sTCP:LISTEN | grep ":<port>"

  Most queries limit results to listening TCP connections. This function likely
  won't work on Mac OSX.

  :param int port: port where the process we're looking for is listening

  :returns: **int** with the process id, **None** if it can't be determined
  """
  ...

def pid_by_open_file(path): # -> int | None:
  """
  Attempts to determine the process id for a process with the given open file,
  using...

  ::

    lsof -w <path>

  :param str path: location of the socket file to query against

  :returns: **int** with the process id, **None** if it can't be determined
  """
  ...

def pids_by_user(user): # -> list[int] | None:
  """
  Provides processes owned by a given user.

  .. versionadded:: 1.5.0

  :param str user: user to look up processes for

  :returns: **list** with the process ids, **None** if it can't be determined
  """
  ...

def cwd(pid): # -> Literal[''] | None:
  """
  Provides the working directory of the given process.

  :param int pid: process id of the process to be queried

  :returns: **str** with the absolute path for the process' present working
    directory, **None** if it can't be determined
  """
  ...

def user(pid): # -> str | None:
  """
  Provides the user a process is running under.

  :param int pid: process id of the process to be queried

  :returns: **str** with the username a process is running under, **None** if
    it can't be determined
  """
  ...

def start_time(pid): # -> float | None:
  """
  Provides the unix timestamp when the given process started.

  :param int pid: process id of the process to be queried

  :returns: **float** for the unix timestamp when the process began, **None**
    if it can't be determined
  """
  ...

def tail(target, lines=...): # -> Generator[Any, Any, None]:
  """
  Provides lines of a file starting with the end. For instance,
  'tail -n 50 /tmp/my_log' could be done with...

  ::

    reversed(list(tail('/tmp/my_log', 50)))

  :param str,file target: path or file object to read from
  :param int lines: number of lines to read

  :returns: **generator** that reads lines, starting with the end

  :raises: **IOError** if unable to read the file
  """
  ...

def bsd_jail_id(pid): # -> int:
  """
  Gets the jail id for a process. These seem to only exist for FreeBSD (this
  style for jails does not exist on Linux, OSX, or OpenBSD).

  :param int pid: process id of the jail id to be queried

  :returns: **int** for the jail id, zero if this can't be determined
  """
  ...

def bsd_jail_path(jid): # -> None:
  """
  Provides the path of the given FreeBSD jail.

  :param int jid: jail id to be queried

  :returns: **str** of the path prefix, **None** if this can't be determined
  """
  ...

def is_tarfile(path): # -> bool:
  """
  Returns if the path belongs to a tarfile or not.

  .. versionadded:: 1.2.0

  :param str path: path to be checked

  :returns: **True** if the path belongs to a tarball, **False** otherwise
  """
  ...

def expand_path(path, cwd=...): # -> str:
  """
  Provides an absolute path, expanding tildes with the user's home and
  appending a current working directory if the path was relative.

  :param str path: path to be expanded
  :param str cwd: current working directory to expand relative paths with, our
    process' if this is **None**

  :returns: **str** of the path expanded to be an absolute path, never with an
    ending slash
  """
  ...

def files_with_suffix(base_path, suffix): # -> Generator[Any, Any, None]:
  """
  Iterates over files in a given directory, providing filenames with a certain
  suffix.

  .. versionadded:: 1.2.0

  :param str base_path: directory to be iterated over
  :param str suffix: filename suffix to look for

  :returns: iterator that yields the absolute path for files with the given suffix
  """
  ...

def call(command, default=..., ignore_exit_status=..., timeout=..., cwd=..., env=...):
  """
  call(command, default = UNDEFINED, ignore_exit_status = False)

  Issues a command in a subprocess, blocking until completion and returning the
  results. This is not actually ran in a shell so pipes and other shell syntax
  are not permitted.

  .. versionchanged:: 1.5.0
     Providing additional information upon failure by raising a CallError. This
     is a subclass of OSError, providing backward compatibility.

  .. versionchanged:: 1.5.0
     Added env argument.

  .. versionchanged:: 1.6.0
     Added timeout and cwd arguments.

  :param str,list command: command to be issued
  :param object default: response if the query fails
  :param bool ignore_exit_status: reports failure if our command's exit status
    was non-zero
  :param float timeout: maximum seconds to wait, blocks indefinitely if
    **None**
  :param dict env: environment variables

  :returns: **list** with the lines of output from the command

  :raises:
    * **CallError** if this fails and no default was provided
    * **CallTimeoutError** if the timeout is reached without a default
  """
  ...

def get_process_name(): # -> LiteralString:
  """
  Provides the present name of our process.

  :returns: **str** with the present name of our process
  """
  ...

def set_process_name(process_name): # -> None:
  """
  Renames our current process from "python <args>" to a custom name. This is
  best-effort, not necessarily working on all platforms.

  :param str process_name: new name for our process

  :raises: **IOError** if the process cannot be renamed
  """
  ...

get_name_by_pid = ...
get_pid_by_name = ...
get_pid_by_port = ...
get_pid_by_open_file = ...
get_cwd = ...
get_user = ...
get_start_time = ...
get_bsd_jail_id = ...
get_bsd_jail_path = ...
