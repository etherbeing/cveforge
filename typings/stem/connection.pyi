"""
This type stub file was generated by pyright.
"""

"""
Functions for connecting and authenticating to the tor process.

The :func:`~stem.connection.connect` function give an easy, one line
method for getting an authenticated control connection. This is handy for CLI
applications and the python interactive interpreter, but does several things
that makes it undesirable for applications (uses stdin/stdout, suppresses
exceptions, etc).

::

  import sys

  from stem.connection import connect

  if __name__ == '__main__':
    controller = connect()

    if not controller:
      sys.exit(1)  # unable to get a connection

    print 'Tor is running version %s' % controller.get_version()
    controller.close()

::

  % python example.py
  Tor is running version 0.2.4.10-alpha-dev (git-8be6058d8f31e578)

... or if Tor isn't running...

::

  % python example.py
  [Errno 111] Connection refused

The :func:`~stem.connection.authenticate` function, however, gives easy but
fine-grained control over the authentication process. For instance...

::

  import sys
  import getpass
  import stem.connection
  import stem.socket

  try:
    control_socket = stem.socket.ControlPort(port = 9051)
  except stem.SocketError as exc:
    print 'Unable to connect to port 9051 (%s)' % exc
    sys.exit(1)

  try:
    stem.connection.authenticate(control_socket)
  except stem.connection.IncorrectSocketType:
    print 'Please check in your torrc that 9051 is the ControlPort.'
    print 'Maybe you configured it to be the ORPort or SocksPort instead?'
    sys.exit(1)
  except stem.connection.MissingPassword:
    controller_password = getpass.getpass('Controller password: ')

    try:
      stem.connection.authenticate_password(control_socket, controller_password)
    except stem.connection.PasswordAuthFailed:
      print 'Unable to authenticate, password is incorrect'
      sys.exit(1)
  except stem.connection.AuthenticationFailure as exc:
    print 'Unable to authenticate: %s' % exc
    sys.exit(1)

**Module Overview:**

::

  connect - Simple method for getting authenticated control connection

  authenticate - Main method for authenticating to a control socket
  authenticate_none - Authenticates to an open control socket
  authenticate_password - Authenticates to a socket supporting password auth
  authenticate_cookie - Authenticates to a socket supporting cookie auth
  authenticate_safecookie - Authenticates to a socket supporting safecookie auth

  get_protocolinfo - Issues a PROTOCOLINFO query

  AuthenticationFailure - Base exception raised for authentication failures
    |- UnrecognizedAuthMethods - Authentication methods are unsupported
    |- IncorrectSocketType - Socket does not speak the tor control protocol
    |
    |- OpenAuthFailed - Failure when authenticating by an open socket
    |  +- OpenAuthRejected - Tor rejected this method of authentication
    |
    |- PasswordAuthFailed - Failure when authenticating by a password
    |  |- PasswordAuthRejected - Tor rejected this method of authentication
    |  |- IncorrectPassword - Password was rejected
    |  +- MissingPassword - Socket supports password auth but wasn't attempted
    |
    |- CookieAuthFailed - Failure when authenticating by a cookie
    |  |- CookieAuthRejected - Tor rejected this method of authentication
    |  |- IncorrectCookieValue - Authentication cookie was rejected
    |  |- IncorrectCookieSize - Size of the cookie file is incorrect
    |  |- UnreadableCookieFile - Unable to read the contents of the auth cookie
    |  +- AuthChallengeFailed - Failure completing the authchallenge request
    |     |- AuthChallengeUnsupported - Tor doesn't recognize the AUTHCHALLENGE command
    |     |- AuthSecurityFailure - Server provided the wrong nonce credentials
    |     |- InvalidClientNonce - The client nonce is invalid
    |     +- UnrecognizedAuthChallengeMethod - AUTHCHALLENGE does not support the given methods.
    |
    +- MissingAuthInfo - Unexpected PROTOCOLINFO response, missing auth info
       |- NoAuthMethods - Missing any methods for authenticating
       +- NoAuthCookie - Supports cookie auth but doesn't have its path

.. data:: AuthMethod (enum)

  Enumeration of PROTOCOLINFO responses for supported authentication methods.

  ============== ===========
  AuthMethod     Description
  ============== ===========
  **NONE**       No authentication required.
  **PASSWORD**   Password required, see tor's HashedControlPassword option.
  **COOKIE**     Contents of the cookie file required, see tor's CookieAuthentication option.
  **SAFECOOKIE** Need to reply to a hmac challenge using the contents of the cookie file.
  **UNKNOWN**    Tor provided one or more authentication methods that we don't recognize, probably something new.
  ============== ===========
"""
AuthMethod = ...
CLIENT_HASH_CONSTANT = ...
SERVER_HASH_CONSTANT = ...
CRYPTOVARIABLE_EQUALITY_COMPARISON_NONCE = ...
MISSING_PASSWORD_BUG_MSG = ...
UNRECOGNIZED_AUTH_TYPE_MSG = ...
UNREADABLE_COOKIE_FILE_MSG = ...
WRONG_PORT_TYPE_MSG = ...
WRONG_SOCKET_TYPE_MSG = ...
CONNECT_MESSAGES = ...
COMMON_TOR_COMMANDS = ...
def connect(control_port=..., control_socket=..., password=..., password_prompt=..., chroot_path=..., controller=...): # -> None:
  """
  Convenience function for quickly getting a control connection. This is very
  handy for debugging or CLI setup, handling setup and prompting for a password
  if necessary (and none is provided). If any issues arise this prints a
  description of the problem and returns **None**.

  If both a **control_port** and **control_socket** are provided then the
  **control_socket** is tried first, and this provides a generic error message
  if they're both unavailable.

  In much the same vein as git porcelain commands, users should not rely on
  details of how this works. Messages and details of this function's behavior
  could change in the future.

  If the **port** is **'default'** then this checks on both 9051 (default for
  relays) and 9151 (default for the Tor Browser). This default may change in
  the future.

  .. versionadded:: 1.2.0

  .. versionchanged:: 1.5.0
     Use both port 9051 and 9151 by default.

  :param tuple contol_port: address and port tuple, for instance **('127.0.0.1', 9051)**
  :param str path: path where the control socket is located
  :param str password: passphrase to authenticate to the socket
  :param bool password_prompt: prompt for the controller password if it wasn't
    supplied
  :param str chroot_path: path prefix if in a chroot environment
  :param Class controller: :class:`~stem.control.BaseController` subclass to be
    returned, this provides a :class:`~stem.socket.ControlSocket` if **None**

  :returns: authenticated control connection, the type based on the controller argument

  :raises: **ValueError** if given an invalid control_port, or both
    **control_port** and **control_socket** are **None**
  """
  ...

def connect_port(address=..., port=..., password=..., chroot_path=..., controller=...): # -> None:
  """
  Convenience function for quickly getting a control connection. This is very
  handy for debugging or CLI setup, handling setup and prompting for a password
  if necessary (and none is provided). If any issues arise this prints a
  description of the problem and returns **None**.

  .. deprecated:: 1.2.0
     Use :func:`~stem.connection.connect` instead.

  :param str address: ip address of the controller
  :param int port: port number of the controller
  :param str password: passphrase to authenticate to the socket
  :param str chroot_path: path prefix if in a chroot environment
  :param Class controller: :class:`~stem.control.BaseController` subclass to be
    returned, this provides a :class:`~stem.socket.ControlSocket` if **None**

  :returns: authenticated control connection, the type based on the controller argument
  """
  ...

def connect_socket_file(path=..., password=..., chroot_path=..., controller=...): # -> None:
  """
  Convenience function for quickly getting a control connection. For more
  information see the :func:`~stem.connection.connect_port` function.

  In much the same vein as git porcelain commands, users should not rely on
  details of how this works. Messages or details of this function's behavior
  might change in the future.

  .. deprecated:: 1.2.0
     Use :func:`~stem.connection.connect` instead.

  :param str path: path where the control socket is located
  :param str password: passphrase to authenticate to the socket
  :param str chroot_path: path prefix if in a chroot environment
  :param Class controller: :class:`~stem.control.BaseController` subclass to be
    returned, this provides a :class:`~stem.socket.ControlSocket` if **None**

  :returns: authenticated control connection, the type based on the controller argument
  """
  ...

def authenticate(controller, password=..., chroot_path=..., protocolinfo_response=...):
  """
  Authenticates to a control socket using the information provided by a
  PROTOCOLINFO response. In practice this will often be all we need to
  authenticate, raising an exception if all attempts to authenticate fail.

  All exceptions are subclasses of AuthenticationFailure so, in practice,
  callers should catch the types of authentication failure that they care
  about, then have a :class:`~stem.connection.AuthenticationFailure` catch-all
  at the end.

  This can authenticate to either a :class:`~stem.control.BaseController` or
  :class:`~stem.socket.ControlSocket`.

  :param controller: tor controller or socket to be authenticated
  :param str password: passphrase to present to the socket if it uses password
    authentication (skips password auth if **None**)
  :param str chroot_path: path prefix if in a chroot environment
  :param stem.response.protocolinfo.ProtocolInfoResponse protocolinfo_response:
    tor protocolinfo response, this is retrieved on our own if **None**

  :raises: If all attempts to authenticate fails then this will raise a
    :class:`~stem.connection.AuthenticationFailure` subclass. Since this may
    try multiple authentication methods it may encounter multiple exceptions.
    If so then the exception this raises is prioritized as follows...

    * :class:`stem.connection.IncorrectSocketType`

      The controller does not speak the tor control protocol. Most often this
      happened because the user confused the SocksPort or ORPort with the
      ControlPort.

    * :class:`stem.connection.UnrecognizedAuthMethods`

      All of the authentication methods tor will accept are new and
      unrecognized. Please upgrade stem and, if that doesn't work, file a
      ticket on 'trac.torproject.org' and I'd be happy to add support.

    * :class:`stem.connection.MissingPassword`

      We were unable to authenticate but didn't attempt password authentication
      because none was provided. You should prompt the user for a password and
      try again via 'authenticate_password'.

    * :class:`stem.connection.IncorrectPassword`

      We were provided with a password but it was incorrect.

    * :class:`stem.connection.IncorrectCookieSize`

      Tor allows for authentication by reading it a cookie file, but that file
      is the wrong size to be an authentication cookie.

    * :class:`stem.connection.UnreadableCookieFile`

      Tor allows for authentication by reading it a cookie file, but we can't
      read that file (probably due to permissions).

    * **\\***:class:`stem.connection.IncorrectCookieValue`

      Tor allows for authentication by reading it a cookie file, but rejected
      the contents of that file.

    * **\\***:class:`stem.connection.AuthChallengeUnsupported`

      Tor doesn't recognize the AUTHCHALLENGE command. This is probably a Tor
      version prior to SAFECOOKIE being implement, but this exception shouldn't
      arise because we won't attempt SAFECOOKIE auth unless Tor claims to
      support it.

    * **\\***:class:`stem.connection.UnrecognizedAuthChallengeMethod`

      Tor couldn't recognize the AUTHCHALLENGE method Stem sent to it. This
      shouldn't happen at all.

    * **\\***:class:`stem.connection.InvalidClientNonce`

      Tor says that the client nonce provided by Stem during the AUTHCHALLENGE
      process is invalid.

    * **\\***:class:`stem.connection.AuthSecurityFailure`

      Nonce value provided by the server was invalid.

    * **\\***:class:`stem.connection.OpenAuthRejected`

      Tor says that it allows for authentication without any credentials, but
      then rejected our authentication attempt.

    * **\\***:class:`stem.connection.MissingAuthInfo`

      Tor provided us with a PROTOCOLINFO reply that is technically valid, but
      missing the information we need to authenticate.

    * **\\***:class:`stem.connection.AuthenticationFailure`

      There are numerous other ways that authentication could have failed
      including socket failures, malformed controller responses, etc. These
      mostly constitute transient failures or bugs.

    **\\*** In practice it is highly unusual for this to occur, being more of a
    theoretical possibility rather than something you should expect. It's fine
    to treat these as errors. If you have a use case where this commonly
    happens, please file a ticket on 'trac.torproject.org'.

    In the future new :class:`~stem.connection.AuthenticationFailure`
    subclasses may be added to allow for better error handling.
  """
  ...

def authenticate_none(controller, suppress_ctl_errors=...): # -> None:
  """
  Authenticates to an open control socket. All control connections need to
  authenticate before they can be used, even if tor hasn't been configured to
  use any authentication.

  If authentication fails tor will disconnect and we'll make a best effort
  attempt to re-establish the connection. This may not succeed, so check
  :func:`~stem.socket.ControlSocket.is_alive` before using the socket further.

  This can authenticate to either a :class:`~stem.control.BaseController` or
  :class:`~stem.socket.ControlSocket`.

  For general usage use the :func:`~stem.connection.authenticate` function
  instead.

  :param controller: tor controller or socket to be authenticated
  :param bool suppress_ctl_errors: reports raised
    :class:`~stem.ControllerError` as authentication rejection if
    **True**, otherwise they're re-raised

  :raises: :class:`stem.connection.OpenAuthRejected` if the empty authentication credentials aren't accepted
  """
  ...

def authenticate_password(controller, password, suppress_ctl_errors=...): # -> None:
  """
  Authenticates to a control socket that uses a password (via the
  HashedControlPassword torrc option). Quotes in the password are escaped.

  If authentication fails tor will disconnect and we'll make a best effort
  attempt to re-establish the connection. This may not succeed, so check
  :func:`~stem.socket.ControlSocket.is_alive` before using the socket further.

  If you use this function directly, rather than
  :func:`~stem.connection.authenticate`, we may mistakenly raise a
  PasswordAuthRejected rather than IncorrectPassword. This is because we rely
  on tor's error messaging which is liable to change in future versions
  (:trac:`4817`).

  This can authenticate to either a :class:`~stem.control.BaseController` or
  :class:`~stem.socket.ControlSocket`.

  For general usage use the :func:`~stem.connection.authenticate` function
  instead.

  :param controller: tor controller or socket to be authenticated
  :param str password: passphrase to present to the socket
  :param bool suppress_ctl_errors: reports raised
    :class:`~stem.ControllerError` as authentication rejection if
    **True**, otherwise they're re-raised

  :raises:
    * :class:`stem.connection.PasswordAuthRejected` if the socket doesn't
      accept password authentication
    * :class:`stem.connection.IncorrectPassword` if the authentication
      credentials aren't accepted
  """
  ...

def authenticate_cookie(controller, cookie_path, suppress_ctl_errors=...): # -> None:
  """
  Authenticates to a control socket that uses the contents of an authentication
  cookie (generated via the CookieAuthentication torrc option). This does basic
  validation that this is a cookie before presenting the contents to the
  socket.

  The :class:`~stem.connection.IncorrectCookieSize` and
  :class:`~stem.connection.UnreadableCookieFile` exceptions take precedence
  over the other types.

  If authentication fails tor will disconnect and we'll make a best effort
  attempt to re-establish the connection. This may not succeed, so check
  :func:`~stem.socket.ControlSocket.is_alive` before using the socket further.

  If you use this function directly, rather than
  :func:`~stem.connection.authenticate`, we may mistakenly raise a
  :class:`~stem.connection.CookieAuthRejected` rather than
  :class:`~stem.connection.IncorrectCookieValue`. This is because we rely on
  tor's error messaging which is liable to change in future versions
  (:trac:`4817`).

  This can authenticate to either a :class:`~stem.control.BaseController` or
  :class:`~stem.socket.ControlSocket`.

  For general usage use the :func:`~stem.connection.authenticate` function
  instead.

  :param controller: tor controller or socket to be authenticated
  :param str cookie_path: path of the authentication cookie to send to tor
  :param bool suppress_ctl_errors: reports raised
    :class:`~stem.ControllerError` as authentication rejection if
    **True**, otherwise they're re-raised

  :raises:
    * :class:`stem.connection.IncorrectCookieSize` if the cookie file's size
      is wrong
    * :class:`stem.connection.UnreadableCookieFile` if the cookie file doesn't
      exist or we're unable to read it
    * :class:`stem.connection.CookieAuthRejected` if cookie authentication is
      attempted but the socket doesn't accept it
    * :class:`stem.connection.IncorrectCookieValue` if the cookie file's value
      is rejected
  """
  ...

def authenticate_safecookie(controller, cookie_path, suppress_ctl_errors=...): # -> None:
  """
  Authenticates to a control socket using the safe cookie method, which is
  enabled by setting the CookieAuthentication torrc option on Tor client's which
  support it.

  Authentication with this is a two-step process...

  1. send a nonce to the server and receives a challenge from the server for
     the cookie's contents
  2. generate a hash digest using the challenge received in the first step, and
     use it to authenticate the controller

  The :class:`~stem.connection.IncorrectCookieSize` and
  :class:`~stem.connection.UnreadableCookieFile` exceptions take precedence
  over the other exception types.

  The :class:`~stem.connection.AuthChallengeUnsupported`,
  :class:`~stem.connection.UnrecognizedAuthChallengeMethod`,
  :class:`~stem.connection.InvalidClientNonce` and
  :class:`~stem.connection.CookieAuthRejected` exceptions are next in the order
  of precedence. Depending on the reason, one of these is raised if the first
  (AUTHCHALLENGE) step fails.

  In the second (AUTHENTICATE) step,
  :class:`~stem.connection.IncorrectCookieValue` or
  :class:`~stem.connection.CookieAuthRejected` maybe raised.

  If authentication fails tor will disconnect and we'll make a best effort
  attempt to re-establish the connection. This may not succeed, so check
  :func:`~stem.socket.ControlSocket.is_alive` before using the socket further.

  For general usage use the :func:`~stem.connection.authenticate` function
  instead.

  :param controller: tor controller or socket to be authenticated
  :param str cookie_path: path of the authentication cookie to send to tor
  :param bool suppress_ctl_errors: reports raised
    :class:`~stem.ControllerError` as authentication rejection if
    **True**, otherwise they're re-raised

  :raises:
    * :class:`stem.connection.IncorrectCookieSize` if the cookie file's size
      is wrong
    * :class:`stem.connection.UnreadableCookieFile` if the cookie file doesn't
      exist or we're unable to read it
    * :class:`stem.connection.CookieAuthRejected` if cookie authentication is
      attempted but the socket doesn't accept it
    * :class:`stem.connection.IncorrectCookieValue` if the cookie file's value
      is rejected
    * :class:`stem.connection.UnrecognizedAuthChallengeMethod` if the Tor
      client fails to recognize the AuthChallenge method
    * :class:`stem.connection.AuthChallengeUnsupported` if AUTHCHALLENGE is
      unimplemented, or if unable to parse AUTHCHALLENGE response
    * :class:`stem.connection.AuthSecurityFailure` if AUTHCHALLENGE's response
      looks like a security attack
    * :class:`stem.connection.InvalidClientNonce` if stem's AUTHCHALLENGE
      client nonce is rejected for being invalid
  """
  ...

def get_protocolinfo(controller):
  """
  Issues a PROTOCOLINFO query to a control socket, getting information about
  the tor process running on it. If the socket is already closed then it is
  first reconnected.

  This can authenticate to either a :class:`~stem.control.BaseController` or
  :class:`~stem.socket.ControlSocket`.

  :param controller: tor controller or socket to be queried

  :returns: :class:`~stem.response.protocolinfo.ProtocolInfoResponse` provided by tor

  :raises:
    * :class:`stem.ProtocolError` if the PROTOCOLINFO response is
      malformed
    * :class:`stem.SocketError` if problems arise in establishing or
      using the socket
  """
  ...

class AuthenticationFailure(Exception):
  """
  Base error for authentication failures.

  :var stem.socket.ControlMessage auth_response: AUTHENTICATE response from the
    control socket, **None** if one wasn't received
  """
  def __init__(self, message, auth_response=...) -> None:
    ...
  


class UnrecognizedAuthMethods(AuthenticationFailure):
  """
  All methods for authenticating aren't recognized.

  :var list unknown_auth_methods: authentication methods that weren't recognized
  """
  def __init__(self, message, unknown_auth_methods) -> None:
    ...
  


class IncorrectSocketType(AuthenticationFailure):
  'Socket does not speak the control protocol.'
  ...


class OpenAuthFailed(AuthenticationFailure):
  'Failure to authenticate to an open socket.'
  ...


class OpenAuthRejected(OpenAuthFailed):
  'Attempt to connect to an open control socket was rejected.'
  ...


class PasswordAuthFailed(AuthenticationFailure):
  'Failure to authenticate with a password.'
  ...


class PasswordAuthRejected(PasswordAuthFailed):
  'Socket does not support password authentication.'
  ...


class IncorrectPassword(PasswordAuthFailed):
  'Authentication password incorrect.'
  ...


class MissingPassword(PasswordAuthFailed):
  "Password authentication is supported but we weren't provided with one."
  ...


class CookieAuthFailed(AuthenticationFailure):
  """
  Failure to authenticate with an authentication cookie.

  :param str cookie_path: location of the authentication cookie we attempted
  :param bool is_safecookie: **True** if this was for SAFECOOKIE
    authentication, **False** if for COOKIE
  :param stem.response.ControlMessage auth_response: reply to our
    authentication attempt
  """
  def __init__(self, message, cookie_path, is_safecookie, auth_response=...) -> None:
    ...
  


class CookieAuthRejected(CookieAuthFailed):
  'Socket does not support password authentication.'
  ...


class IncorrectCookieValue(CookieAuthFailed):
  'Authentication cookie value was rejected.'
  ...


class IncorrectCookieSize(CookieAuthFailed):
  'Aborted because the cookie file is the wrong size.'
  ...


class UnreadableCookieFile(CookieAuthFailed):
  'Error arose in reading the authentication cookie.'
  ...


class AuthChallengeFailed(CookieAuthFailed):
  """
  AUTHCHALLENGE command has failed.
  """
  def __init__(self, message, cookie_path) -> None:
    ...
  


class AuthChallengeUnsupported(AuthChallengeFailed):
  """
  AUTHCHALLENGE isn't implemented.
  """
  ...


class UnrecognizedAuthChallengeMethod(AuthChallengeFailed):
  """
  Tor couldn't recognize our AUTHCHALLENGE method.

  :var str authchallenge_method: AUTHCHALLENGE method that Tor couldn't recognize
  """
  def __init__(self, message, cookie_path, authchallenge_method) -> None:
    ...
  


class AuthSecurityFailure(AuthChallengeFailed):
  'AUTHCHALLENGE response is invalid.'
  ...


class InvalidClientNonce(AuthChallengeFailed):
  'AUTHCHALLENGE request contains an invalid client nonce.'
  ...


class MissingAuthInfo(AuthenticationFailure):
  """
  The PROTOCOLINFO response didn't have enough information to authenticate.
  These are valid control responses but really shouldn't happen in practice.
  """
  ...


class NoAuthMethods(MissingAuthInfo):
  "PROTOCOLINFO response didn't have any methods for authenticating."
  ...


class NoAuthCookie(MissingAuthInfo):
  """
  PROTOCOLINFO response supports cookie auth but doesn't have its path.

  :param bool is_safecookie: **True** if this was for SAFECOOKIE
    authentication, **False** if for COOKIE
  """
  def __init__(self, message, is_safecookie) -> None:
    ...
  


AUTHENTICATE_EXCEPTIONS = ...
