"""
This type stub file was generated by pyright.
"""

import base64
import codecs
import collections
import copy
import io
import os
import random
import re
import string
import tarfile
import stem.prereq
import stem.util
import stem.util.enum
import stem.util.str_tools
import stem.util.system
import stem.descriptor.bandwidth_file
import stem.descriptor.extrainfo_descriptor
import stem.descriptor.hidden_service
import stem.descriptor.microdescriptor
import stem.descriptor.networkstatus
import stem.descriptor.server_descriptor
import stem.descriptor.tordnsel
from collections import OrderedDict

"""
Package for parsing and processing descriptor data.

**Module Overview:**

::

  parse_file - Parses the descriptors in a file.
  create_signing_key - Cretes a signing key that can be used for creating descriptors.

  Compression - method of descriptor decompression

  Descriptor - Common parent for all descriptor file types.
    | |- content - creates the text of a new descriptor
    | |- create - creates a new descriptor
    | +- from_str - provides a parsed descriptor for the given string
    |
    |- type_annotation - provides our @type annotation
    |- get_path - location of the descriptor on disk if it came from a file
    |- get_archive_path - location of the descriptor within the archive it came from
    |- get_bytes - similar to str(), but provides our original bytes content
    |- get_unrecognized_lines - unparsed descriptor content
    +- __str__ - string that the descriptor was made from

.. data:: DigestHash (enum)

  .. versionadded:: 1.8.0

  Hash function used by tor for descriptor digests.

  =========== ===========
  DigestHash  Description
  =========== ===========
  SHA1        SHA1 hash
  SHA256      SHA256 hash
  =========== ===========

.. data:: DigestEncoding (enum)

  .. versionadded:: 1.8.0

  Encoding of descriptor digests.

  ================= ===========
  DigestEncoding    Description
  ================= ===========
  RAW               hash object
  HEX               uppercase hexidecimal encoding
  BASE64            base64 encoding `without trailing '=' padding <https://en.wikipedia.org/wiki/Base64#Decoding_Base64_without_padding>`_
  ================= ===========

.. data:: DocumentHandler (enum)

  Ways in which we can parse a
  :class:`~stem.descriptor.networkstatus.NetworkStatusDocument`.

  Both **ENTRIES** and **BARE_DOCUMENT** have a 'thin' document, which doesn't
  have a populated **routers** attribute. This allows for lower memory usage
  and upfront runtime. However, if read time and memory aren't a concern then
  **DOCUMENT** can provide you with a fully populated document.

  Handlers don't change the fact that most methods that provide
  descriptors return an iterator. In the case of **DOCUMENT** and
  **BARE_DOCUMENT** that iterator would have just a single item -
  the document itself.

  Simple way to handle this is to call **next()** to get the iterator's one and
  only value...

  ::

    import stem.descriptor.remote
    from stem.descriptor import DocumentHandler

    consensus = next(stem.descriptor.remote.get_consensus(
      document_handler = DocumentHandler.BARE_DOCUMENT,
    )


  =================== ===========
  DocumentHandler     Description
  =================== ===========
  **ENTRIES**         Iterates over the contained :class:`~stem.descriptor.router_status_entry.RouterStatusEntry`. Each has a reference to the bare document it came from (through its **document** attribute).
  **DOCUMENT**        :class:`~stem.descriptor.networkstatus.NetworkStatusDocument` with the :class:`~stem.descriptor.router_status_entry.RouterStatusEntry` it contains (through its **routers** attribute).
  **BARE_DOCUMENT**   :class:`~stem.descriptor.networkstatus.NetworkStatusDocument` **without** a reference to its contents (the :class:`~stem.descriptor.router_status_entry.RouterStatusEntry` are unread).
  =================== ===========
"""
__all__ = ['bandwidth_file', 'certificate', 'collector', 'export', 'extrainfo_descriptor', 'hidden_service', 'microdescriptor', 'networkstatus', 'reader', 'remote', 'router_status_entry', 'server_descriptor', 'tordnsel', 'Descriptor', 'parse_file']
UNSEEKABLE_MSG = ...
KEYWORD_CHAR = ...
WHITESPACE = ...
KEYWORD_LINE = ...
SPECIFIC_KEYWORD_LINE = ...
PGP_BLOCK_START = ...
PGP_BLOCK_END = ...
EMPTY_COLLECTION = ...
DIGEST_TYPE_INFO = ...
DIGEST_PADDING = ...
DIGEST_SEPARATOR = ...
CRYPTO_BLOB = ...
DigestHash = ...
DigestEncoding = ...
DocumentHandler = ...
class _Compression:
  """
  Compression method supported by CollecTor.

  :var bool available: **True** if this method of decryption is available,
    **False** otherwise
  :var str encoding: `http 'Accept-Encoding' parameter <https://en.wikipedia.org/wiki/HTTP_compression#Content-Encoding_tokens>`_
  :var str extension: file extension of this compression

  .. versionadded:: 1.8.0
  """
  def __init__(self, name, module, encoding, extension, decompression_func) -> None:
    ...
  
  def decompress(self, content):
    """
    Decompresses the given content via this method.

    :param bytes content: content to be decompressed

    :returns: **bytes** with the decompressed content

    :raises:
      If unable to decompress this provide...

      * **IOError** if content isn't compressed with this
      * **ImportError** if this method if decompression is unavalable
    """
    ...
  
  def __str__(self) -> str:
    ...
  


Compression = ...
class TypeAnnotation(collections.namedtuple('TypeAnnotation', ['name', 'major_version', 'minor_version'])):
  """
  `Tor metrics type annotation
  <https://metrics.torproject.org/collector.html#relay-descriptors>`_. The
  string representation is the header annotation, for example "@type
  server-descriptor 1.0".

  .. versionadded:: 1.8.0

  :var str name: name of the descriptor type
  :var int major_version: major version number
  :var int minor_version: minor version number
  """
  def __str__(self) -> str:
    ...
  


class SigningKey(collections.namedtuple('SigningKey', ['private', 'public', 'public_digest'])):
  """
  Key used by relays to sign their server and extrainfo descriptors.

  .. versionadded:: 1.6.0

  :var cryptography.hazmat.backends.openssl.rsa._RSAPrivateKey private: private key
  :var cryptography.hazmat.backends.openssl.rsa._RSAPublicKey public: public key
  :var bytes public_digest: block that can be used for the a server descrptor's 'signing-key' field
  """
  ...


def parse_file(descriptor_file, descriptor_type=..., validate=..., document_handler=..., normalize_newlines=..., **kwargs): # -> Generator[Any | BridgeDescriptor | RelayDescriptor | BridgeExtraInfoDescriptor | RelayExtraInfoDescriptor | Microdescriptor | NetworkStatusDocumentV3 | BridgeNetworkStatusDocument | NetworkStatusDocumentV2, Any, None]:
  """
  Simple function to read the descriptor contents from a file, providing an
  iterator for its :class:`~stem.descriptor.__init__.Descriptor` contents.

  If you don't provide a **descriptor_type** argument then this automatically
  tries to determine the descriptor type based on the following...

  * The @type annotation on the first line. These are generally only found in
    the `CollecTor archives <https://metrics.torproject.org/collector.html#relay-descriptors>`_.

  * The filename if it matches something from tor's data directory. For
    instance, tor's 'cached-descriptors' contains server descriptors.

  This is a handy function for simple usage, but if you're reading multiple
  descriptor files you might want to consider the
  :class:`~stem.descriptor.reader.DescriptorReader`.

  Descriptor types include the following, including further minor versions (ie.
  if we support 1.1 then we also support everything from 1.0 and most things
  from 1.2, but not 2.0)...

  ========================================= =====
  Descriptor Type                           Class
  ========================================= =====
  server-descriptor 1.0                     :class:`~stem.descriptor.server_descriptor.RelayDescriptor`
  extra-info 1.0                            :class:`~stem.descriptor.extrainfo_descriptor.RelayExtraInfoDescriptor`
  microdescriptor 1.0                       :class:`~stem.descriptor.microdescriptor.Microdescriptor`
  directory 1.0                             **unsupported**
  network-status-2 1.0                      :class:`~stem.descriptor.router_status_entry.RouterStatusEntryV2` (with a :class:`~stem.descriptor.networkstatus.NetworkStatusDocumentV2`)
  dir-key-certificate-3 1.0                 :class:`~stem.descriptor.networkstatus.KeyCertificate`
  network-status-consensus-3 1.0            :class:`~stem.descriptor.router_status_entry.RouterStatusEntryV3` (with a :class:`~stem.descriptor.networkstatus.NetworkStatusDocumentV3`)
  network-status-vote-3 1.0                 :class:`~stem.descriptor.router_status_entry.RouterStatusEntryV3` (with a :class:`~stem.descriptor.networkstatus.NetworkStatusDocumentV3`)
  network-status-microdesc-consensus-3 1.0  :class:`~stem.descriptor.router_status_entry.RouterStatusEntryMicroV3` (with a :class:`~stem.descriptor.networkstatus.NetworkStatusDocumentV3`)
  bridge-network-status 1.0                 :class:`~stem.descriptor.router_status_entry.RouterStatusEntryV3` (with a :class:`~stem.descriptor.networkstatus.BridgeNetworkStatusDocument`)
  bridge-server-descriptor 1.0              :class:`~stem.descriptor.server_descriptor.BridgeDescriptor`
  bridge-extra-info 1.1 or 1.2              :class:`~stem.descriptor.extrainfo_descriptor.BridgeExtraInfoDescriptor`
  torperf 1.0                               **unsupported**
  bridge-pool-assignment 1.0                **unsupported**
  tordnsel 1.0                              :class:`~stem.descriptor.tordnsel.TorDNSEL`
  hidden-service-descriptor 1.0             :class:`~stem.descriptor.hidden_service.HiddenServiceDescriptorV2`
  ========================================= =====

  If you're using **python 3** then beware that the open() function defaults to
  using text mode. **Binary mode** is strongly suggested because it's both
  faster (by my testing by about 33x) and doesn't do universal newline
  translation which can make us misparse the document.

  ::

    my_descriptor_file = open(descriptor_path, 'rb')

  :param str,file,tarfile descriptor_file: path or opened file with the descriptor contents
  :param str descriptor_type: `descriptor type <https://metrics.torproject.org/collector.html#data-formats>`_, this is guessed if not provided
  :param bool validate: checks the validity of the descriptor's content if
    **True**, skips these checks otherwise
  :param stem.descriptor.__init__.DocumentHandler document_handler: method in
    which to parse the :class:`~stem.descriptor.networkstatus.NetworkStatusDocument`
  :param bool normalize_newlines: converts windows newlines (CRLF), this is the
    default when reading data directories on windows
  :param dict kwargs: additional arguments for the descriptor constructor

  :returns: iterator for :class:`~stem.descriptor.__init__.Descriptor` instances in the file

  :raises:
    * **ValueError** if the contents is malformed and validate is True
    * **TypeError** if we can't match the contents of the file to a descriptor type
    * **IOError** if unable to read from the descriptor_file
  """
  ...

class Descriptor:
  """
  Common parent for all types of descriptors.
  """
  ATTRIBUTES = ...
  PARSER_FOR_LINE = ...
  TYPE_ANNOTATION_NAME = ...
  def __init__(self, contents, lazy_load=...) -> None:
    ...
  
  @classmethod
  def from_str(cls, content, **kwargs): # -> list[Any | BridgeDescriptor | RelayDescriptor | BridgeExtraInfoDescriptor | RelayExtraInfoDescriptor | Microdescriptor | NetworkStatusDocumentV3 | BridgeNetworkStatusDocument | NetworkStatusDocumentV2] | BridgeDescriptor | RelayDescriptor | BridgeExtraInfoDescriptor | RelayExtraInfoDescriptor | Microdescriptor | NetworkStatusDocumentV3 | BridgeNetworkStatusDocument | NetworkStatusDocumentV2:
    """
    Provides a :class:`~stem.descriptor.__init__.Descriptor` for the given content.

    To parse a descriptor we must know its type. There are three ways to
    convey this...

    ::

      # use a descriptor_type argument
      desc = Descriptor.from_str(content, descriptor_type = 'server-descriptor 1.0')

      # prefixing the content with a "@type" annotation
      desc = Descriptor.from_str('@type server-descriptor 1.0\\n' + content)

      # use this method from a subclass
      desc = stem.descriptor.server_descriptor.RelayDescriptor.from_str(content)

    .. versionadded:: 1.8.0

    :param str,bytes content: string to construct the descriptor from
    :param bool multiple: if provided with **True** this provides a list of
      descriptors rather than a single one
    :param dict kwargs: additional arguments for :func:`~stem.descriptor.__init__.parse_file`

    :returns: :class:`~stem.descriptor.__init__.Descriptor` subclass for the
      given content, or a **list** of descriptors if **multiple = True** is
      provided

    :raises:
      * **ValueError** if the contents is malformed and validate is True
      * **TypeError** if we can't match the contents of the file to a descriptor type
      * **IOError** if unable to read from the descriptor_file
    """
    ...
  
  @classmethod
  def content(cls, attr=..., exclude=..., sign=...):
    """
    Creates descriptor content with the given attributes. Mandatory fields are
    filled with dummy information unless data is supplied. This doesn't yet
    create a valid signature.

    .. versionadded:: 1.6.0

    :param dict attr: keyword/value mappings to be included in the descriptor
    :param list exclude: mandatory keywords to exclude from the descriptor, this
      results in an invalid descriptor
    :param bool sign: includes cryptographic signatures and digests if True

    :returns: **str** with the content of a descriptor

    :raises:
      * **ImportError** if cryptography is unavailable and sign is True
      * **NotImplementedError** if not implemented for this descriptor type
    """
    ...
  
  @classmethod
  def create(cls, attr=..., exclude=..., validate=..., sign=...): # -> Self:
    """
    Creates a descriptor with the given attributes. Mandatory fields are filled
    with dummy information unless data is supplied. This doesn't yet create a
    valid signature.

    .. versionadded:: 1.6.0

    :param dict attr: keyword/value mappings to be included in the descriptor
    :param list exclude: mandatory keywords to exclude from the descriptor, this
      results in an invalid descriptor
    :param bool validate: checks the validity of the descriptor's content if
      **True**, skips these checks otherwise
    :param bool sign: includes cryptographic signatures and digests if True

    :returns: :class:`~stem.descriptor.Descriptor` subclass

    :raises:
      * **ValueError** if the contents is malformed and validate is True
      * **ImportError** if cryptography is unavailable and sign is True
      * **NotImplementedError** if not implemented for this descriptor type
    """
    ...
  
  def type_annotation(self): # -> TypeAnnotation:
    """
    Provides the `Tor metrics annotation
    <https://metrics.torproject.org/collector.html#relay-descriptors>`_ of this
    descriptor type. For example, "@type server-descriptor 1.0" for server
    descriptors.

    Please note that the version number component is specific to CollecTor,
    and for the moment hardcode as 1.0. This may change in the future.

    .. versionadded:: 1.8.0

    :returns: :class:`~stem.descriptor.TypeAnnotation` with our type information
    """
    ...
  
  def get_path(self): # -> None:
    """
    Provides the absolute path that we loaded this descriptor from.

    :returns: **str** with the absolute path of the descriptor source
    """
    ...
  
  def get_archive_path(self): # -> None:
    """
    If this descriptor came from an archive then provides its path within the
    archive. This is only set if the descriptor came from a
    :class:`~stem.descriptor.reader.DescriptorReader`, and is **None** if this
    descriptor didn't come from an archive.

    :returns: **str** with the descriptor's path within the archive
    """
    ...
  
  def get_bytes(self): # -> bytes:
    """
    Provides the ASCII **bytes** of the descriptor. This only differs from
    **str()** if you're running python 3.x, in which case **str()** provides a
    **unicode** string.

    :returns: **bytes** for the descriptor's contents
    """
    ...
  
  def get_unrecognized_lines(self): # -> list[Any]:
    """
    Provides a list of lines that were either ignored or had data that we did
    not know how to process. This is most common due to new descriptor fields
    that this library does not yet know how to process. Patches welcome!

    :returns: **list** of lines of unrecognized content
    """
    ...
  
  def __getattr__(self, name): # -> Any:
    ...
  
  def __str__(self) -> str:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __ne__(self, other) -> bool:
    ...
  
  def __lt__(self, other) -> bool:
    ...
  
  def __le__(self, other) -> bool:
    ...
  


class NewlineNormalizer:
  """
  File wrapper that normalizes CRLF line endings.
  """
  def __init__(self, wrapped_file) -> None:
    ...
  
  def read(self, *args):
    ...
  
  def readline(self, *args):
    ...
  
  def readlines(self, *args): # -> list[Any]:
    ...
  
  def seek(self, *args):
    ...
  
  def tell(self, *args):
    ...
  


def create_signing_key(private_key=...): # -> SigningKey:
  """
  Serializes a signing key if we have one. Otherwise this creates a new signing
  key we can use to create descriptors.

  .. versionadded:: 1.6.0

  :param cryptography.hazmat.backends.openssl.rsa._RSAPrivateKey private_key: private key

  :returns: :class:`~stem.descriptor.__init__.SigningKey` that can be used to
    create descriptors

  :raises: **ImportError** if the cryptography module is unavailable
  """
  ...

