"""
This type stub file was generated by pyright.
"""

import collections
from stem.descriptor import Descriptor

"""
Parsing for Tor network status documents. This supports both the v2 and v3
`dir-spec <https://gitweb.torproject.org/torspec.git/tree/dir-spec.txt>`_.
Documents can be obtained from a few sources...

* The 'cached-consensus' file in Tor's data directory.

* Archived descriptors provided by `CollecTor
  <https://metrics.torproject.org/collector.html>`_.

* Directory authorities and mirrors via their DirPort.

... and contain the following sections...

* document header
* list of :class:`stem.descriptor.networkstatus.DirectoryAuthority`
* list of :class:`stem.descriptor.router_status_entry.RouterStatusEntry`
* document footer

**For a great graphical overview see** `Jordan Wright's chart describing the
anatomy of the consensus
<https://jordan-wright.github.io/images/blog/how_tor_works/consensus.png>`_.

Of these, the router status entry section can be quite large (on the order of
hundreds of kilobytes). As such we provide a couple of methods for reading
network status documents through :func:`~stem.descriptor.__init__.parse_file`.
For more information see :func:`~stem.descriptor.__init__.DocumentHandler`...

::

  from stem.descriptor import parse_file, DocumentHandler

  with open('.tor/cached-consensus', 'rb') as consensus_file:
    # Processes the routers as we read them in. The routers refer to a document
    # with an unset 'routers' attribute.

    for router in parse_file(consensus_file, 'network-status-consensus-3 1.0', document_handler = DocumentHandler.ENTRIES):
      print router.nickname

**Module Overview:**

::

  NetworkStatusDocument - Network status document
    |- NetworkStatusDocumentV2 - Version 2 network status document
    |- NetworkStatusDocumentV3 - Version 3 network status document
    +- BridgeNetworkStatusDocument - Version 3 network status document for bridges

  KeyCertificate - Certificate used to authenticate an authority
  DocumentSignature - Signature of a document by a directory authority
  DetachedSignature - Stand alone signature used when making the consensus
  DirectoryAuthority - Directory authority as defined in a v3 network status document
"""
NETWORK_STATUS_V2_FIELDS = ...
HEADER_STATUS_DOCUMENT_FIELDS = ...
FOOTER_STATUS_DOCUMENT_FIELDS = ...
AUTH_START = ...
ROUTERS_START = ...
FOOTER_START = ...
V2_FOOTER_START = ...
DEFAULT_PARAMS = ...
KEY_CERTIFICATE_PARAMS = ...
DETACHED_SIGNATURE_PARAMS = ...
PARAM_RANGE = ...
class PackageVersion(collections.namedtuple('PackageVersion', ['name', 'version', 'url', 'digests'])):
  """
  Latest recommended version of a package that's available.

  :var str name: name of the package
  :var str version: latest recommended version
  :var str url: package's url
  :var dict digests: mapping of digest types to their value
  """
  ...


class SharedRandomnessCommitment(collections.namedtuple('SharedRandomnessCommitment', ['version', 'algorithm', 'identity', 'commit', 'reveal'])):
  """
  Directory authority's commitment for generating the next shared random value.

  :var int version: shared randomness protocol version
  :var str algorithm: hash algorithm used to make the commitment
  :var str identity: authority's sha1 identity fingerprint
  :var str commit: base64 encoded commitment hash to the shared random value
  :var str reveal: base64 encoded commitment to the shared random value,
    **None** of not provided
  """
  ...


class DocumentDigest(collections.namedtuple('DocumentDigest', ['flavor', 'algorithm', 'digest'])):
  """
  Digest of a consensus document.

  .. versionadded:: 1.8.0

  :var str flavor: consensus type this digest is for (for example, 'microdesc')
  :var str algorithm: hash algorithm used to make the digest
  :var str digest: digest value of the consensus
  """
  ...


class NetworkStatusDocument(Descriptor):
  """
  Common parent for network status documents.
  """
  def digest(self, hash_type=..., encoding=...): # -> HASH:
    """
    Digest of this descriptor's content. These are referenced by...

      * **DetachedSignature**

        * Referer: :class:`~stem.descriptor.networkstatus.DetachedSignature` **consensus_digest** attribute
        * Format: **SHA1/HEX**

    .. versionadded:: 1.8.0

    :param stem.descriptor.DigestHash hash_type: digest hashing algorithm
    :param stem.descriptor.DigestEncoding encoding: digest encoding

    :returns: **hashlib.HASH** or **str** based on our encoding argument
    """
    ...
  


_parse_network_status_version_line = ...
_parse_fingerprint_line = ...
_parse_contact_line = ...
_parse_dir_signing_key_line = ...
_parse_client_versions_line = ...
_parse_server_versions_line = ...
_parse_published_line = ...
_parse_dir_options_line = ...
_parse_directory_signature_line = ...
_parse_consensus_digest_line = ...
class NetworkStatusDocumentV2(NetworkStatusDocument):
  """
  Version 2 network status document. These have been deprecated and are no
  longer generated by Tor.

  :var dict routers: fingerprints to :class:`~stem.descriptor.router_status_entry.RouterStatusEntryV2`
    contained in the document

  :var int version: **\\*** document version

  :var str hostname: **\\*** hostname of the authority
  :var str address: **\\*** authority's IP address
  :var int dir_port: **\\*** authority's DirPort
  :var str fingerprint: **\\*** authority's fingerprint
  :var str contact: **\\*** authority's contact information
  :var str signing_key: **\\*** authority's public signing key

  :var list client_versions: list of recommended client tor version strings
  :var list server_versions: list of recommended server tor version strings
  :var datetime published: **\\*** time when the document was published
  :var list options: **\\*** list of things that this authority decides

  :var str signing_authority: **\\*** name of the authority signing the document
  :var str signature: **\\*** authority's signature for the document

  **\\*** attribute is either required when we're parsed with validation or has
  a default value, others are left as **None** if undefined
  """
  TYPE_ANNOTATION_NAME = ...
  ATTRIBUTES = ...
  PARSER_FOR_LINE = ...
  @classmethod
  def content(cls, attr=..., exclude=..., sign=...): # -> bytes:
    ...
  
  def __init__(self, raw_content, validate=...) -> None:
    ...
  


_parse_header_valid_after_line = ...
_parse_header_fresh_until_line = ...
_parse_header_valid_until_line = ...
_parse_header_client_versions_line = ...
_parse_header_server_versions_line = ...
_parse_header_known_flags_line = ...
_parse_footer_bandwidth_weights_line = ...
_parse_shared_rand_participate_line = ...
_parse_recommended_client_protocols_line = ...
_parse_recommended_relay_protocols_line = ...
_parse_required_client_protocols_line = ...
_parse_required_relay_protocols_line = ...
class NetworkStatusDocumentV3(NetworkStatusDocument):
  """
  Version 3 network status document. This could be either a vote or consensus.

  :var dict routers: fingerprint to :class:`~stem.descriptor.router_status_entry.RouterStatusEntryV3`
    mapping for relays contained in the document

  :var int version: **\\*** document version
  :var str version_flavor: **\\*** flavor associated with the document (such as 'ns' or 'microdesc')
  :var bool is_consensus: **\\*** **True** if the document is a consensus
  :var bool is_vote: **\\*** **True** if the document is a vote
  :var bool is_microdescriptor: **\\*** **True** if this is a microdescriptor
    flavored document, **False** otherwise
  :var datetime valid_after: **\\*** time when the consensus became valid
  :var datetime fresh_until: **\\*** time when the next consensus should be produced
  :var datetime valid_until: **\\*** time when this consensus becomes obsolete
  :var int vote_delay: **\\*** number of seconds allowed for collecting votes
    from all authorities
  :var int dist_delay: **\\*** number of seconds allowed for collecting
    signatures from all authorities
  :var list client_versions: list of recommended client tor versions
  :var list server_versions: list of recommended server tor versions
  :var list packages: **\\*** list of :data:`~stem.descriptor.networkstatus.PackageVersion` entries
  :var list known_flags: **\\*** list of :data:`~stem.Flag` for the router's flags
  :var dict params: **\\*** dict of parameter(**str**) => value(**int**) mappings
  :var list directory_authorities: **\\*** list of :class:`~stem.descriptor.networkstatus.DirectoryAuthority`
    objects that have generated this document
  :var list signatures: **\\*** :class:`~stem.descriptor.networkstatus.DocumentSignature`
    of the authorities that have signed the document

  **Consensus Attributes:**

  :var int consensus_method: method version used to generate this consensus
  :var dict bandwidth_weights: dict of weight(str) => value(int) mappings

  :var int shared_randomness_current_reveal_count: number of commitments
    used to generate the current shared random value
  :var str shared_randomness_current_value: base64 encoded current shared
    random value

  :var int shared_randomness_previous_reveal_count: number of commitments
    used to generate the last shared random value
  :var str shared_randomness_previous_value: base64 encoded last shared random
    value

  **Vote Attributes:**

  :var list consensus_methods: list of ints for the supported method versions
  :var datetime published: time when the document was published
  :var dict flag_thresholds: **\\*** mapping of internal performance thresholds used while making the vote, values are **ints** or **floats**

  :var dict recommended_client_protocols: recommended protocols for clients
  :var dict recommended_relay_protocols: recommended protocols for relays
  :var dict required_client_protocols: required protocols for clients
  :var dict required_relay_protocols: required protocols for relays
  :var dict bandwidth_file_headers: headers from the bandwidth authority that
    generated this vote
  :var dict bandwidth_file_digest: hashes of the bandwidth authority file used
    to generate this vote, this is a mapping of hash functions to their resulting
    digest value

  **\\*** attribute is either required when we're parsed with validation or has
  a default value, others are left as None if undefined

  .. versionchanged:: 1.4.0
     Added the packages attribute.

  .. versionchanged:: 1.5.0
     Added the is_shared_randomness_participate, shared_randomness_commitments,
     shared_randomness_previous_reveal_count,
     shared_randomness_previous_value,
     shared_randomness_current_reveal_count, and
     shared_randomness_current_value attributes.

  .. versionchanged:: 1.6.0
     Added the recommended_client_protocols, recommended_relay_protocols,
     required_client_protocols, and required_relay_protocols attributes.

  .. versionchanged:: 1.6.0
     The is_shared_randomness_participate and shared_randomness_commitments
     were misdocumented in the tor spec and as such never set. They're now an
     attribute of votes in the **directory_authorities**.

  .. versionchanged:: 1.7.0
     The shared_randomness_current_reveal_count and
     shared_randomness_previous_reveal_count attributes were undocumented and
     not provided properly if retrieved before their shred_randomness_*_value
     counterpart.

  .. versionchanged:: 1.7.0
     Added the bandwidth_file_headers attributbute.

  .. versionchanged:: 1.8.0
     Added the bandwidth_file_digest attributbute.
  """
  ATTRIBUTES = ...
  _HEADER_PARSER_FOR_LINE = ...
  _FOOTER_PARSER_FOR_LINE = ...
  @classmethod
  def content(cls, attr=..., exclude=..., sign=..., authorities=..., routers=...): # -> bytes:
    ...
  
  @classmethod
  def create(cls, attr=..., exclude=..., validate=..., sign=..., authorities=..., routers=...): # -> Self:
    ...
  
  def __init__(self, raw_content, validate=..., default_params=...) -> None:
    """
    Parse a v3 network status document.

    :param str raw_content: raw network status document data
    :param bool validate: **True** if the document is to be validated, **False** otherwise
    :param bool default_params: includes defaults in our params dict, otherwise
      it just contains values from the document

    :raises: **ValueError** if the document is invalid
    """
    ...
  
  def type_annotation(self): # -> TypeAnnotation:
    ...
  
  def is_valid(self): # -> Any:
    """
    Checks if the current time is between this document's **valid_after** and
    **valid_until** timestamps. To be valid means the information within this
    document reflects the current network state.

    .. versionadded:: 1.8.0

    :returns: **True** if this consensus is presently valid and **False**
      otherwise
    """
    ...
  
  def is_fresh(self): # -> Any:
    """
    Checks if the current time is between this document's **valid_after** and
    **fresh_until** timestamps. To be fresh means this should be the latest
    consensus.

    .. versionadded:: 1.8.0

    :returns: **True** if this consensus is presently fresh and **False**
      otherwise
    """
    ...
  
  def validate_signatures(self, key_certs): # -> None:
    """
    Validates we're properly signed by the signing certificates.

    .. versionadded:: 1.6.0

    :param list key_certs: :class:`~stem.descriptor.networkstatus.KeyCertificates`
      to validate the consensus against

    :raises: **ValueError** if an insufficient number of valid signatures are present.
    """
    ...
  
  def get_unrecognized_lines(self): # -> list[Any]:
    ...
  
  def meets_consensus_method(self, method): # -> bool:
    """
    Checks if we meet the given consensus-method. This works for both votes and
    consensuses, checking our 'consensus-method' and 'consensus-methods'
    entries.

    :param int method: consensus-method to check for

    :returns: **True** if we meet the given consensus-method, and **False** otherwise
    """
    ...
  


_parse_legacy_dir_key_line = ...
_parse_vote_digest_line = ...
class DirectoryAuthority(Descriptor):
  """
  Directory authority information obtained from a v3 network status document.

  Authorities can optionally use a legacy format. These are no longer found in
  practice, but have the following differences...

  * The authority's nickname ends with '-legacy'.
  * There's no **contact** or **vote_digest** attribute.

  :var str nickname: **\\*** authority's nickname
  :var str v3ident: **\\*** identity key fingerprint used to sign votes and consensus
  :var str hostname: **\\*** hostname of the authority
  :var str address: **\\*** authority's IP address
  :var int dir_port: **\\*** authority's DirPort
  :var int or_port: **\\*** authority's ORPort
  :var bool is_legacy: **\\*** if the authority's using the legacy format
  :var str contact: contact information, this is included if is_legacy is **False**

  **Consensus Attributes:**

  :var str vote_digest: digest of the authority that contributed to the consensus, this is included if is_legacy is **False**

  **Vote Attributes:**

  :var str legacy_dir_key: fingerprint of and obsolete identity key
  :var stem.descriptor.networkstatus.KeyCertificate key_certificate: **\\***
    authority's key certificate

  :var bool is_shared_randomness_participate: **\\*** **True** if this authority
    participates in establishing a shared random value, **False** otherwise
  :var list shared_randomness_commitments: **\\*** list of
    :data:`~stem.descriptor.networkstatus.SharedRandomnessCommitment` entries
  :var int shared_randomness_previous_reveal_count: number of commitments
    used to generate the last shared random value
  :var str shared_randomness_previous_value: base64 encoded last shared random
    value
  :var int shared_randomness_current_reveal_count: number of commitments
    used to generate the current shared random value
  :var str shared_randomness_current_value: base64 encoded current shared
    random value

  **\\*** mandatory attribute

  .. versionchanged:: 1.4.0
     Renamed our 'fingerprint' attribute to 'v3ident' (prior attribute exists
     for backward compatability, but is deprecated).

  .. versionchanged:: 1.6.0
     Added the is_shared_randomness_participate, shared_randomness_commitments,
     shared_randomness_previous_reveal_count,
     shared_randomness_previous_value,
     shared_randomness_current_reveal_count, and
     shared_randomness_current_value attributes.
  """
  ATTRIBUTES = ...
  PARSER_FOR_LINE = ...
  @classmethod
  def content(cls, attr=..., exclude=..., sign=..., is_vote=...): # -> bytes:
    ...
  
  @classmethod
  def create(cls, attr=..., exclude=..., validate=..., sign=..., is_vote=...): # -> Self:
    ...
  
  def __init__(self, raw_content, validate=..., is_vote=...) -> None:
    """
    Parse a directory authority entry in a v3 network status document.

    :param str raw_content: raw directory authority entry information
    :param bool validate: checks the validity of the content if True, skips
      these checks otherwise
    :param bool is_vote: True if this is for a vote, False if it's for a consensus

    :raises: ValueError if the descriptor data is invalid
    """
    ...
  


_parse_dir_key_certificate_version_line = ...
_parse_dir_key_published_line = ...
_parse_dir_key_expires_line = ...
_parse_identity_key_line = ...
_parse_signing_key_line = ...
_parse_dir_key_crosscert_line = ...
_parse_dir_key_certification_line = ...
class KeyCertificate(Descriptor):
  """
  Directory key certificate for a v3 network status document.

  :var int version: **\\*** version of the key certificate
  :var str address: authority's IP address
  :var int dir_port: authority's DirPort
  :var str fingerprint: **\\*** authority's fingerprint
  :var str identity_key: **\\*** long term authority identity key
  :var datetime published: **\\*** time when this key was generated
  :var datetime expires: **\\*** time after which this key becomes invalid
  :var str signing_key: **\\*** directory server's public signing key
  :var str crosscert: signature made using certificate's signing key
  :var str certification: **\\*** signature of this key certificate signed with
    the identity key

  **\\*** mandatory attribute
  """
  TYPE_ANNOTATION_NAME = ...
  ATTRIBUTES = ...
  PARSER_FOR_LINE = ...
  @classmethod
  def content(cls, attr=..., exclude=..., sign=...): # -> bytes:
    ...
  
  def __init__(self, raw_content, validate=...) -> None:
    ...
  


class DocumentSignature:
  """
  Directory signature of a v3 network status document.

  :var str method: algorithm used to make the signature
  :var str identity: fingerprint of the authority that made the signature
  :var str key_digest: digest of the signing key
  :var str signature: document signature
  :var str flavor: consensus type this signature is for (such as 'microdesc'),
    **None** if for the standard consensus
  :param bool validate: checks validity if **True**

  :raises: **ValueError** if a validity check fails
  """
  def __init__(self, method, identity, key_digest, signature, flavor=..., validate=...) -> None:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __ne__(self, other) -> bool:
    ...
  
  def __lt__(self, other) -> bool:
    ...
  
  def __le__(self, other) -> bool:
    ...
  


class DetachedSignature(Descriptor):
  """
  Stand alone signature of the consensus. These are exchanged between directory
  authorities when determining the next hour's consensus.

  Detached signatures are defined in section 3.10 of the dir-spec, and only
  available to be downloaded for five minutes between minute 55 until the end
  of the hour.

  .. versionadded:: 1.8.0

  :var str consensus_digest: **\\*** digest of the consensus being signed
  :var datetime valid_after: **\\*** time when the consensus became valid
  :var datetime fresh_until: **\\*** time when the next consensus should be produced
  :var datetime valid_until: **\\*** time when this consensus becomes obsolete
  :var list additional_digests: **\\***
    :class:`~stem.descriptor.networkstatus.DocumentDigest` for additional
    consensus flavors
  :var list additional_signatures: **\\***
    :class:`~stem.descriptor.networkstatus.DocumentSignature` for additional
    consensus flavors
  :var list signatures: **\\*** :class:`~stem.descriptor.networkstatus.DocumentSignature`
    of the authorities that have signed the document

  **\\*** mandatory attribute
  """
  TYPE_ANNOTATION_NAME = ...
  ATTRIBUTES = ...
  PARSER_FOR_LINE = ...
  @classmethod
  def content(cls, attr=..., exclude=..., sign=...): # -> bytes:
    ...
  
  def __init__(self, raw_content, validate=...) -> None:
    ...
  


class BridgeNetworkStatusDocument(NetworkStatusDocument):
  """
  Network status document containing bridges. This is only available through
  the metrics site.

  :var dict routers: fingerprint to :class:`~stem.descriptor.router_status_entry.RouterStatusEntryV3`
    mapping for relays contained in the document
  :var datetime published: time when the document was published
  """
  TYPE_ANNOTATION_NAME = ...
  def __init__(self, raw_content, validate=...) -> None:
    ...
  


