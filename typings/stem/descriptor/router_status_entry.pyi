"""
This type stub file was generated by pyright.
"""

from stem.descriptor import Descriptor

"""
Parsing for router status entries, the information for individual routers
within a network status document. This information is provided from a few
sources...

* control port via 'GETINFO ns/\\*' and 'GETINFO md/\\*' queries
* router entries in a network status document, like the cached-consensus

**Module Overview:**

::

  RouterStatusEntry - Common parent for router status entries
    |- RouterStatusEntryV2 - Entry for a network status v2 document
    |   +- RouterStatusEntryBridgeV2 - Entry for a bridge flavored v2 document
    |
    |- RouterStatusEntryV3 - Entry for a network status v3 document
    +- RouterStatusEntryMicroV3 - Entry for a microdescriptor flavored v3 document
"""
_parse_pr_line = ...
class RouterStatusEntry(Descriptor):
  """
  Information about an individual router stored within a network status
  document. This is the common parent for concrete status entry types.

  :var stem.descriptor.networkstatus.NetworkStatusDocument document: **\\*** document that this descriptor came from

  :var str nickname: **\\*** router's nickname
  :var str fingerprint: **\\*** router's fingerprint
  :var datetime published: **\\*** router's publication
  :var str address: **\\*** router's IP address
  :var int or_port: **\\*** router's ORPort
  :var int dir_port: **\\*** router's DirPort

  :var list flags: **\\*** list of :data:`~stem.Flag` associated with the relay

  :var stem.version.Version version: parsed version of tor, this is **None** if
    the relay's using a new versioning scheme
  :var str version_line: versioning information reported by the relay
  """
  ATTRIBUTES = ...
  PARSER_FOR_LINE = ...
  @classmethod
  def from_str(cls, content, **kwargs): # -> list[Any]:
    ...
  
  def __init__(self, content, validate=..., document=...) -> None:
    """
    Parse a router descriptor in a network status document.

    :param str content: router descriptor content to be parsed
    :param NetworkStatusDocument document: document this descriptor came from
    :param bool validate: checks the validity of the content if **True**, skips
      these checks otherwise

    :raises: **ValueError** if the descriptor data is invalid
    """
    ...
  


class RouterStatusEntryV2(RouterStatusEntry):
  """
  Information about an individual router stored within a version 2 network
  status document.

  :var str digest: **\\*** router's upper-case hex digest

  **\\*** attribute is either required when we're parsed with validation or has
  a default value, others are left as **None** if undefined
  """
  TYPE_ANNOTATION_NAME = ...
  ATTRIBUTES = ...
  @classmethod
  def content(cls, attr=..., exclude=..., sign=...): # -> bytes:
    ...
  


class RouterStatusEntryBridgeV2(RouterStatusEntryV2):
  """
  Information about an individual router stored within a bridge flavored
  version 2 network status document.

  .. versionadded:: 1.8.0
  """
  TYPE_ANNOTATION_NAME = ...


class RouterStatusEntryV3(RouterStatusEntry):
  """
  Information about an individual router stored within a version 3 network
  status document.

  :var list or_addresses: **\\*** relay's OR addresses, this is a tuple listing
    of the form (address (**str**), port (**int**), is_ipv6 (**bool**))
  :var str identifier_type: identity digest key type
  :var str identifier: base64 encoded identity digest
  :var str digest: **\\*** router's upper-case hex digest

  :var int bandwidth: bandwidth measured to be available by the relay, this is
    an arbitrary units (currently kilobytes per second) heuristic generated by
    the Bandwidth authoritites to weight relay selection
  :var int measured: *bandwidth* vote provided by a bandwidth authority
  :var bool is_unmeasured: *bandwidth* measurement isn't based on three or more
    measurements
  :var list unrecognized_bandwidth_entries: **\\*** bandwidth weighting
    information that isn't yet recognized

  :var stem.exit_policy.MicroExitPolicy exit_policy: router's exit policy
  :var dict protocols: mapping of protocols to their supported versions

  :var list microdescriptor_hashes: **\\*** tuples of two values, the list of
    consensus methods for generating a set of digests and the 'algorithm =>
    digest' mappings

  **\\*** attribute is either required when we're parsed with validation or has
  a default value, others are left as **None** if undefined

  .. versionchanged:: 1.5.0
     Added the identifier and identifier_type attributes.

  .. versionchanged:: 1.6.0
     Added the protocols attribute.
  """
  TYPE_ANNOTATION_NAME = ...
  ATTRIBUTES = ...
  PARSER_FOR_LINE = ...
  @classmethod
  def content(cls, attr=..., exclude=..., sign=...): # -> bytes:
    ...
  


class RouterStatusEntryMicroV3(RouterStatusEntry):
  """
  Information about an individual router stored within a microdescriptor
  flavored network status document.

  :var list or_addresses: **\\*** relay's OR addresses, this is a tuple listing
    of the form (address (**str**), port (**int**), is_ipv6 (**bool**))
  :var int bandwidth: bandwidth claimed by the relay (in kb/s)
  :var int measured: bandwidth measured to be available by the relay
  :var bool is_unmeasured: bandwidth measurement isn't based on three or more
    measurements
  :var list unrecognized_bandwidth_entries: **\\*** bandwidth weighting
    information that isn't yet recognized
  :var dict protocols: mapping of protocols to their supported versions

  :var str digest: **\\*** router's hex encoded digest of our corresponding
    microdescriptor (**deprecated**, use microdescriptor_digest instead)
  :var str microdescriptor_digest: **\\*** router's base64 encoded digest of our corresponding microdescriptor

  .. versionchanged:: 1.6.0
     Added the protocols attribute.

  .. versionchanged:: 1.7.0
     Added the or_addresses attribute.

  .. versionchanged:: 1.7.0
     Added the microdescriptor_digest attribute to replace our now deprecated digest attribute.

  **\\*** attribute is either required when we're parsed with validation or has
  a default value, others are left as **None** if undefined
  """
  TYPE_ANNOTATION_NAME = ...
  ATTRIBUTES = ...
  PARSER_FOR_LINE = ...
  @classmethod
  def content(cls, attr=..., exclude=..., sign=...): # -> bytes:
    ...
  


