"""
This type stub file was generated by pyright.
"""

"""
Supports communication with sockets speaking Tor protocols. This
allows us to send messages as basic strings, and receive responses as
:class:`~stem.response.ControlMessage` instances.

**This module only consists of low level components, and is not intended for
users.** See our `tutorials <../tutorials.html>`_ and `Control Module
<control.html>`_ if you're new to Stem and looking to get started.

With that aside, these can still be used for raw socket communication with
Tor...

::

  import stem
  import stem.connection
  import stem.socket

  if __name__ == '__main__':
    try:
      control_socket = stem.socket.ControlPort(port = 9051)
      stem.connection.authenticate(control_socket)
    except stem.SocketError as exc:
      print 'Unable to connect to tor on port 9051: %s' % exc
      sys.exit(1)
    except stem.connection.AuthenticationFailure as exc:
      print 'Unable to authenticate: %s' % exc
      sys.exit(1)

    print "Issuing 'GETINFO version' query...\\n"
    control_socket.send('GETINFO version')
    print control_socket.recv()

::

  % python example.py
  Issuing 'GETINFO version' query...

  version=0.2.4.10-alpha-dev (git-8be6058d8f31e578)
  OK

**Module Overview:**

::

  BaseSocket - Thread safe socket.
    |- RelaySocket - Socket for a relay's ORPort.
    |  |- send - sends a message to the socket
    |  +- recv - receives a response from the socket
    |
    |- ControlSocket - Socket wrapper that speaks the tor control protocol.
    |  |- ControlPort - Control connection via a port.
    |  |- ControlSocketFile - Control connection via a local file socket.
    |  |
    |  |- send - sends a message to the socket
    |  +- recv - receives a ControlMessage from the socket
    |
    |- is_alive - reports if the socket is known to be closed
    |- is_localhost - returns if the socket is for the local system or not
    |- connection_time - timestamp when socket last connected or disconnected
    |- connect - connects a new socket
    |- close - shuts down the socket
    +- __enter__ / __exit__ - manages socket connection

  send_message - Writes a message to a control socket.
  recv_message - Reads a ControlMessage from a control socket.
  send_formatting - Performs the formatting expected from sent messages.
"""
MESSAGE_PREFIX = ...
ERROR_MSG = ...
TRUNCATE_LOGS = ...
class BaseSocket:
  """
  Thread safe socket, providing common socket functionality.
  """
  def __init__(self) -> None:
    ...
  
  def is_alive(self): # -> bool:
    """
    Checks if the socket is known to be closed. We won't be aware if it is
    until we either use it or have explicitily shut it down.

    In practice a socket derived from a port knows about its disconnection
    after failing to receive data, whereas socket file derived connections
    know after either sending or receiving data.

    This means that to have reliable detection for when we're disconnected
    you need to continually pull from the socket (which is part of what the
    :class:`~stem.control.BaseController` does).

    :returns: **bool** that's **True** if our socket is connected and **False**
      otherwise
    """
    ...
  
  def is_localhost(self): # -> Literal[False]:
    """
    Returns if the connection is for the local system or not.

    :returns: **bool** that's **True** if the connection is for the local host
      and **False** otherwise
    """
    ...
  
  def connection_time(self): # -> float:
    """
    Provides the unix timestamp for when our socket was either connected or
    disconnected. That is to say, the time we connected if we're currently
    connected and the time we disconnected if we're not connected.

    .. versionadded:: 1.3.0

    :returns: **float** for when we last connected or disconnected, zero if
      we've never connected
    """
    ...
  
  def connect(self): # -> None:
    """
    Connects to a new socket, closing our previous one if we're already
    attached.

    :raises: :class:`stem.SocketError` if unable to make a socket
    """
    ...
  
  def close(self): # -> None:
    """
    Shuts down the socket. If it's already closed then this is a no-op.
    """
    ...
  
  def __enter__(self): # -> Self:
    ...
  
  def __exit__(self, exit_type, value, traceback): # -> None:
    ...
  


class RelaySocket(BaseSocket):
  """
  `Link-level connection
  <https://gitweb.torproject.org/torspec.git/tree/tor-spec.txt>`_ to a Tor
  relay.

  .. versionadded:: 1.7.0

  :var str address: address our socket connects to
  :var int port: ORPort our socket connects to
  """
  def __init__(self, address=..., port=..., connect=...) -> None:
    """
    RelaySocket constructor.

    :param str address: ip address of the relay
    :param int port: orport of the relay
    :param bool connect: connects to the socket if True, leaves it unconnected otherwise

    :raises: :class:`stem.SocketError` if connect is **True** and we're
      unable to establish a connection
    """
    ...
  
  def send(self, message): # -> None:
    """
    Sends a message to the relay's ORPort.

    :param str message: message to be formatted and sent to the socket

    :raises:
      * :class:`stem.SocketError` if a problem arises in using the socket
      * :class:`stem.SocketClosed` if the socket is known to be shut down
    """
    ...
  
  def recv(self, timeout=...):
    """
    Receives a message from the relay.

    :param float timeout: maxiumum number of seconds to await a response, this
      blocks indefinitely if **None**

    :returns: bytes for the message received

    :raises:
      * :class:`stem.ProtocolError` the content from the socket is malformed
      * :class:`stem.SocketClosed` if the socket closes before we receive a complete message
    """
    ...
  
  def is_localhost(self): # -> bool:
    ...
  


class ControlSocket(BaseSocket):
  """
  Wrapper for a socket connection that speaks the Tor control protocol. To the
  better part this transparently handles the formatting for sending and
  receiving complete messages.

  Callers should not instantiate this class directly, but rather use subclasses
  which are expected to implement the **_make_socket()** method.
  """
  def __init__(self) -> None:
    ...
  
  def send(self, message): # -> None:
    """
    Formats and sends a message to the control socket. For more information see
    the :func:`~stem.socket.send_message` function.

    .. deprecated:: 1.7.0
       The **raw** argument was unhelpful and be removed. Use
       :func:`stem.socket.send_message` if you need this level of control
       instead.

    :param str message: message to be formatted and sent to the socket

    :raises:
      * :class:`stem.SocketError` if a problem arises in using the socket
      * :class:`stem.SocketClosed` if the socket is known to be shut down
    """
    ...
  
  def recv(self):
    """
    Receives a message from the control socket, blocking until we've received
    one. For more information see the :func:`~stem.socket.recv_message` function.

    :returns: :class:`~stem.response.ControlMessage` for the message received

    :raises:
      * :class:`stem.ProtocolError` the content from the socket is malformed
      * :class:`stem.SocketClosed` if the socket closes before we receive a complete message
    """
    ...
  


class ControlPort(ControlSocket):
  """
  Control connection to tor. For more information see tor's ControlPort torrc
  option.

  :var str address: address our socket connects to
  :var int port: ControlPort our socket connects to
  """
  def __init__(self, address=..., port=..., connect=...) -> None:
    """
    ControlPort constructor.

    :param str address: ip address of the controller
    :param int port: port number of the controller
    :param bool connect: connects to the socket if True, leaves it unconnected otherwise

    :raises: :class:`stem.SocketError` if connect is **True** and we're
      unable to establish a connection
    """
    ...
  
  def get_address(self): # -> str:
    """
    Provides the ip address our socket connects to.

    .. deprecated:: 1.7.0
       Use the **address** attribute instead.

    :returns: str with the ip address of our socket
    """
    ...
  
  def get_port(self): # -> int:
    """
    Provides the port our socket connects to.

    .. deprecated:: 1.7.0
       Use the **port** attribute instead.

    :returns: int with the port of our socket
    """
    ...
  
  def is_localhost(self): # -> bool:
    ...
  


class ControlSocketFile(ControlSocket):
  """
  Control connection to tor. For more information see tor's ControlSocket torrc
  option.

  :var str path: filesystem path of the socket we connect to
  """
  def __init__(self, path=..., connect=...) -> None:
    """
    ControlSocketFile constructor.

    :param str socket_path: path where the control socket is located
    :param bool connect: connects to the socket if True, leaves it unconnected otherwise

    :raises: :class:`stem.SocketError` if connect is **True** and we're
      unable to establish a connection
    """
    ...
  
  def get_socket_path(self): # -> str:
    """
    Provides the path our socket connects to.

    .. deprecated:: 1.7.0
       Use the **path** attribute instead.

    :returns: str with the path for our control socket
    """
    ...
  
  def is_localhost(self): # -> Literal[True]:
    ...
  


def send_message(control_file, message, raw=...): # -> None:
  """
  Sends a message to the control socket, adding the expected formatting for
  single verses multi-line messages. Neither message type should contain an
  ending newline (if so it'll be treated as a multi-line message with a blank
  line at the end). If the message doesn't contain a newline then it's sent
  as...

  ::

    <message>\\r\\n

  and if it does contain newlines then it's split on ``\\n`` and sent as...

  ::

    +<line 1>\\r\\n
    <line 2>\\r\\n
    <line 3>\\r\\n
    .\\r\\n

  :param file control_file: file derived from the control socket (see the
    socket's makefile() method for more information)
  :param str message: message to be sent on the control socket
  :param bool raw: leaves the message formatting untouched, passing it to the
    socket as-is

  :raises:
    * :class:`stem.SocketError` if a problem arises in using the socket
    * :class:`stem.SocketClosed` if the socket is known to be shut down
  """
  ...

def recv_message(control_file, arrived_at=...): # -> ControlMessage:
  """
  Pulls from a control socket until we either have a complete message or
  encounter a problem.

  :param file control_file: file derived from the control socket (see the
    socket's makefile() method for more information)

  :returns: :class:`~stem.response.ControlMessage` read from the socket

  :raises:
    * :class:`stem.ProtocolError` the content from the socket is malformed
    * :class:`stem.SocketClosed` if the socket closes before we receive
      a complete message
  """
  ...

def send_formatting(message):
  """
  Performs the formatting expected from sent control messages. For more
  information see the :func:`~stem.socket.send_message` function.

  :param str message: message to be formatted

  :returns: **str** of the message wrapped by the formatting expected from
    controllers
  """
  ...

