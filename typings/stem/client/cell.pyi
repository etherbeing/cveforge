"""
This type stub file was generated by pyright.
"""

"""
Messages communicated over a Tor relay's ORPort.

.. versionadded:: 1.7.0

**Module Overview:**

::

  Cell - Base class for ORPort messages.
    |- CircuitCell - Circuit management.
    |  |- CreateCell - Create a circuit.              (section 5.1)
    |  |- CreatedCell - Acknowledge create.           (section 5.1)
    |  |- RelayCell - End-to-end data.                (section 6.1)
    |  |- DestroyCell - Stop using a circuit.         (section 5.4)
    |  |- CreateFastCell - Create a circuit, no PK.   (section 5.1)
    |  |- CreatedFastCell - Circuit created, no PK.   (section 5.1)
    |  |- RelayEarlyCell - End-to-end data; limited.  (section 5.6)
    |  |- Create2Cell - Extended CREATE cell.         (section 5.1)
    |  +- Created2Cell - Extended CREATED cell.       (section 5.1)
    |
    |- PaddingCell - Padding negotiation.             (section 7.2)
    |- VersionsCell - Negotiate proto version.        (section 4)
    |- NetinfoCell - Time and address info.           (section 4.5)
    |- PaddingNegotiateCell - Padding negotiation.    (section 7.2)
    |- VPaddingCell - Variable-length padding.        (section 7.2)
    |- CertsCell - Relay certificates.                (section 4.2)
    |- AuthChallengeCell - Challenge value.           (section 4.3)
    |- AuthenticateCell - Client authentication.      (section 4.5)
    |- AuthorizeCell - Client authorization.          (not yet used)
    |
    |- pack - encodes cell into bytes
    |- unpack - decodes series of cells
    +- pop - decodes cell with remainder
"""
FIXED_PAYLOAD_LEN = ...
AUTH_CHALLENGE_SIZE = ...
CELL_TYPE_SIZE = ...
PAYLOAD_LEN_SIZE = ...
RELAY_DIGEST_SIZE = ...
STREAM_ID_REQUIRED = ...
STREAM_ID_DISALLOWED = ...
class Cell:
  """
  Metadata for ORPort cells.

  Unused padding are **not** used in equality checks or hashing. If two cells
  differ only in their *unused* attribute they are functionally equal.

  The following cell types explicitly don't have *unused* content:
    * PaddingCell (we consider all content part of payload)
    * VersionsCell (all content is unpacked and treated as a version specification)
    * VPaddingCell (we consider all content part of payload)

  :var bytes unused: unused filler that padded the cell to the expected size
  """
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self, unused=...) -> None:
    ...
  
  @staticmethod
  def by_name(name): # -> Any:
    """
    Provides cell attributes by its name.

    :param str name: cell command to fetch

    :raises: **ValueError** if cell type is invalid
    """
    ...
  
  @staticmethod
  def by_value(value): # -> Any:
    """
    Provides cell attributes by its value.

    :param int value: cell value to fetch

    :raises: **ValueError** if cell type is invalid
    """
    ...
  
  def pack(self, link_protocol):
    ...
  
  @staticmethod
  def unpack(content, link_protocol): # -> Generator[Any, Any, None]:
    """
    Unpacks all cells from a response.

    :param bytes content: payload to decode
    :param int link_protocol: link protocol version

    :returns: :class:`~stem.client.cell.Cell` generator

    :raises:
      * ValueError if content is malformed
      * NotImplementedError if unable to unpack any of the cell types
    """
    ...
  
  @staticmethod
  def pop(content, link_protocol): # -> tuple[Any, Any]:
    """
    Unpacks the first cell.

    :param bytes content: payload to decode
    :param int link_protocol: link protocol version

    :returns: (:class:`~stem.client.cell.Cell`, remainder) tuple

    :raises:
      * ValueError if content is malformed
      * NotImplementedError if unable to unpack this cell type
    """
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __ne__(self, other) -> bool:
    ...
  


class CircuitCell(Cell):
  """
  Cell concerning circuits.

  :var int circ_id: circuit id
  """
  def __init__(self, circ_id, unused=...) -> None:
    ...
  


class PaddingCell(Cell):
  """
  Randomized content to either keep activity going on a circuit.

  :var bytes payload: randomized payload
  """
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self, payload=...) -> None:
    ...
  
  def pack(self, link_protocol): # -> bytes:
    ...
  
  def __hash__(self) -> int:
    ...
  


class CreateCell(CircuitCell):
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self) -> None:
    ...
  


class CreatedCell(CircuitCell):
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self) -> None:
    ...
  


class RelayCell(CircuitCell):
  """
  Command concerning a relay circuit.

  Our 'recognized' attribute provides a cheap (but incomplete) check for if our
  cell payload is encrypted. If non-zero our payload *IS* encrypted, but if
  zero we're *PROBABLY* fully decrypted. This uncertainty is because encrypted
  cells have a small chance of coincidently producing zero for this value as
  well.

  :var stem.client.RelayCommand command: command to be issued
  :var int command_int: integer value of our command
  :var bytes data: payload of the cell
  :var int recognized: non-zero if payload is encrypted
  :var int digest: running digest held with the relay
  :var int stream_id: specific stream this concerns
  """
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self, circ_id, command, data, digest=..., stream_id=..., recognized=..., unused=...) -> None:
    ...
  
  def pack(self, link_protocol): # -> bytes:
    ...
  
  @staticmethod
  def decrypt(link_protocol, content, key, digest): # -> tuple[RelayCell, Any, Any]:
    """
    Decrypts content as a relay cell addressed to us. This provides back a
    tuple of the form...

    ::

      (cell (RelayCell), new_key (CipherContext), new_digest (HASH))

    :param int link_protocol: link protocol version
    :param bytes content: cell content to be decrypted
    :param cryptography.hazmat.primitives.ciphers.CipherContext key:
      key established with the relay we received this cell from
    :param hashlib.HASH digest: running digest held with the relay

    :returns: **tuple** with our decrypted cell and updated key/digest

    :raises: :class:`stem.ProtocolError` if content doesn't belong to a relay
      cell
    """
    ...
  
  def encrypt(self, link_protocol, key, digest): # -> tuple[Any, Any, Any]:
    """
    Encrypts our cell content to be sent with the given key. This provides back
    a tuple of the form...

    ::

      (payload (bytes), new_key (CipherContext), new_digest (HASH))

    :param int link_protocol: link protocol version
    :param cryptography.hazmat.primitives.ciphers.CipherContext key:
      key established with the relay we're sending this cell to
    :param hashlib.HASH digest: running digest held with the relay

    :returns: **tuple** with our encrypted payload and updated key/digest
    """
    ...
  
  def __hash__(self) -> int:
    ...
  


class DestroyCell(CircuitCell):
  """
  Closes the given circuit.

  :var stem.client.CloseReason reason: reason the circuit is being closed
  :var int reason_int: integer value of our closure reason
  """
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self, circ_id, reason=..., unused=...) -> None:
    ...
  
  def pack(self, link_protocol): # -> bytes:
    ...
  
  def __hash__(self) -> int:
    ...
  


class CreateFastCell(CircuitCell):
  """
  Create a circuit with our first hop. This is lighter weight than further hops
  because we've already established the relay's identity and secret key.

  :var bytes key_material: randomized key material
  """
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self, circ_id, key_material=..., unused=...) -> None:
    ...
  
  def pack(self, link_protocol): # -> bytes:
    ...
  
  def __hash__(self) -> int:
    ...
  


class CreatedFastCell(CircuitCell):
  """
  CREATE_FAST reply.

  :var bytes key_material: randomized key material
  :var bytes derivative_key: hash proving the relay knows our shared key
  """
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self, circ_id, derivative_key, key_material=..., unused=...) -> None:
    ...
  
  def pack(self, link_protocol): # -> bytes:
    ...
  
  def __hash__(self) -> int:
    ...
  


class VersionsCell(Cell):
  """
  Link version negotiation cell.

  :var list versions: link versions
  """
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self, versions) -> None:
    ...
  
  def pack(self, link_protocol): # -> bytes:
    ...
  
  def __hash__(self) -> int:
    ...
  


class NetinfoCell(Cell):
  """
  Information relays exchange about each other.

  :var datetime timestamp: current time
  :var stem.client.datatype.Address receiver_address: receiver's OR address
  :var list sender_addresses: sender's OR addresses
  """
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self, receiver_address, sender_addresses, timestamp=..., unused=...) -> None:
    ...
  
  def pack(self, link_protocol): # -> bytes:
    ...
  
  def __hash__(self) -> int:
    ...
  


class RelayEarlyCell(CircuitCell):
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self) -> None:
    ...
  


class Create2Cell(CircuitCell):
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self) -> None:
    ...
  


class Created2Cell(Cell):
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self) -> None:
    ...
  


class PaddingNegotiateCell(Cell):
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self) -> None:
    ...
  


class VPaddingCell(Cell):
  """
  Variable length randomized content to either keep activity going on a circuit.

  :var bytes payload: randomized payload
  """
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self, size=..., payload=...) -> None:
    ...
  
  def pack(self, link_protocol): # -> bytes:
    ...
  
  def __hash__(self) -> int:
    ...
  


class CertsCell(Cell):
  """
  Certificate held by the relay we're communicating with.

  :var list certificates: :class:`~stem.client.Certificate` of the relay
  """
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self, certs, unused=...) -> None:
    ...
  
  def pack(self, link_protocol): # -> bytes:
    ...
  
  def __hash__(self) -> int:
    ...
  


class AuthChallengeCell(Cell):
  """
  First step of the authentication handshake.

  :var bytes challenge: random bytes for us to sign to authenticate
  :var list methods: authentication methods supported by the relay we're
    communicating with
  """
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self, methods, challenge=..., unused=...) -> None:
    ...
  
  def pack(self, link_protocol): # -> bytes:
    ...
  
  def __hash__(self) -> int:
    ...
  


class AuthenticateCell(Cell):
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self) -> None:
    ...
  


class AuthorizeCell(Cell):
  NAME = ...
  VALUE = ...
  IS_FIXED_SIZE = ...
  def __init__(self) -> None:
    ...
  


