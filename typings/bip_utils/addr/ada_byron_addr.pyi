"""
This type stub file was generated by pyright.
"""

from enum import IntEnum, unique
from typing import Any, Dict, NamedTuple, Optional, Tuple, Union
from bip_utils.addr.iaddr_decoder import IAddrDecoder
from bip_utils.addr.iaddr_encoder import IAddrEncoder
from bip_utils.bip.bip32 import Bip32Path
from bip_utils.ecc import IPublicKey

"""
Module for Cardano Byron address encoding/decoding. Both legacy and Icarus addresses are supported.

References:
    https://cips.cardano.org/cips/cip19
    https://raw.githubusercontent.com/cardano-foundation/CIPs/master/CIP-0019/CIP-0019-byron-addresses.cddl
"""
@unique
class AdaByronAddrTypes(IntEnum):
    """Enumerative for Cardano Byron address types."""
    PUBLIC_KEY = ...
    REDEMPTION = ...


class AdaByronAddrConst:
    """Class container for Cardano Byron address constants."""
    CHACHA20_POLY1305_ASSOC_DATA: bytes = ...
    CHACHA20_POLY1305_NONCE: bytes = ...
    PAYLOAD_TAG: int = ...


class _AdaByronAddrHdPath:
    """Cardano Byron address HD path class."""
    @staticmethod
    def Decrypt(hd_path_enc_bytes: bytes, hd_path_key_bytes: bytes) -> Bip32Path:
        """
        Encrypt the HD path.

        Args:
            hd_path_enc_bytes (bytes): Encrypted HD path bytes
            hd_path_key_bytes (bytes): HD path key bytes

        Returns:
            Bip32Path object: Bip32Path object

        Raises:
            ValueError: If the decryption fails or the path cannot be decoded
        """
        ...
    
    @staticmethod
    def Encrypt(hd_path: Bip32Path, hd_path_key_bytes: bytes) -> bytes:
        """
        Encrypt the HD path.

        Args:
            hd_path (Bip32Path object): HD path
            hd_path_key_bytes (bytes) : HD path key bytes

        Returns:
            bytes: Computed key bytes
        """
        ...
    


class _AdaByronAddrAttrs(NamedTuple):
    """Utility class for Cardano Byron address attributes."""
    hd_path_enc_bytes: Optional[bytes]
    network_magic: Optional[int]
    @classmethod
    def FromDict(cls, attrs_dict: Dict[int, bytes]) -> _AdaByronAddrAttrs:
        """
        Create from dictionary.

        Args:
            attrs_dict (dict[int, bytes]): Attributes dictionary

        Returns:
            _AdaByronAddrAttrs object: _AdaByronAddrAttrs object

        Raises:
            ValueError: If the dictionary is not valid
        """
        ...
    
    def ToDict(self) -> Dict[int, bytes]:
        """
        Get as a dictionary.

        Returns:
            dict[int, bytes]: Attributes dictionary
        """
        ...
    


class _AdaByronAddrSpendingData(NamedTuple):
    """Utility class for Cardano Byron address spending data."""
    type: AdaByronAddrTypes
    key_bytes: bytes
    ...


class _AdaByronAddrRoot(NamedTuple):
    """Utility class for Cardano Byron address root."""
    type: AdaByronAddrTypes
    spending_data: _AdaByronAddrSpendingData
    attrs: _AdaByronAddrAttrs
    def Hash(self) -> bytes:
        """
        Get the address root hash.

        Returns:
            bytes: Address root hash bytes
        """
        ...
    
    def Serialize(self) -> bytes:
        """
        Serialize the address root.

        Returns:
            bytes: Serialized address root bytes
        """
        ...
    


class _AdaByronAddrPayload(NamedTuple):
    """Utility class for Cardano Byron address payload."""
    root_hash_bytes: bytes
    attrs: _AdaByronAddrAttrs
    type: AdaByronAddrTypes
    @classmethod
    def Deserialize(cls, ser_payload_bytes: bytes) -> _AdaByronAddrPayload:
        """
        Deserialize from payload bytes.

        Args:
            ser_payload_bytes (bytes): Serialized payload bytes

        Returns:
            _AdaByronAddrPayload object: _AdaByronAddrPayload object

        Raises:
            ValueError: If the serialization is not valid
        """
        ...
    
    def Serialize(self) -> bytes:
        """
        Serialize the address payload.

        Returns:
            bytes: Serialized address payload bytes
        """
        ...
    


class _AdaByronAddr(NamedTuple):
    """Utility class for Cardano Byron address."""
    payload: _AdaByronAddrPayload
    @classmethod
    def Decode(cls, addr: str) -> _AdaByronAddr:
        """
        Decode address.

        Args:
            addr (str): Address string

        Returns:
            _AdaByronAddr object: _AdaByronAddr object

        Raises:
            ValueError: If the serialization is not valid
        """
        ...
    
    def Encode(self) -> str:
        """
        Encode address.

        Returns:
            str: Encoded address string
        """
        ...
    
    @classmethod
    def Deserialize(cls, ser_addr_bytes: bytes) -> _AdaByronAddr:
        """
        Deserialize from address bytes.

        Args:
            ser_addr_bytes (bytes): Serialized address bytes

        Returns:
            _AdaByronAddrPayload object: _AdaByronAddrPayload object

        Raises:
            ValueError: If the serialization is not valid
        """
        ...
    
    def Serialize(self) -> bytes:
        """
        Serialize the address.

        Returns:
            bytes: Serialized address bytes
        """
        ...
    


class _AdaByronAddrUtils:
    """Cardano Byron address utility class."""
    @staticmethod
    def EncodeKey(pub_key_bytes: bytes, chain_code_bytes: bytes, addr_type: AdaByronAddrTypes, hd_path_enc_bytes: Optional[bytes] = ...) -> str:
        """
        Encode a public key to Cardano Byron address.

        Args:
            pub_key_bytes (bytes)              : Public key bytes
            chain_code_bytes (bytes)           : Chain code bytes
            addr_type (AdaByronAddrTypes)      : Address type
            hd_path_enc_bytes (bytes, optional): Encrypted HD path bytes

        Returns:
            str: Address string
        """
        ...
    


class AdaByronAddrDecoder(IAddrDecoder):
    """
    Cardano Byron address decoder class.
    It allows the Cardano Byron address decoding.
    """
    @staticmethod
    def DecryptHdPath(hd_path_enc_bytes: bytes, hd_path_key_bytes: bytes) -> Bip32Path:
        """
        Decrypt an HD path using the specified key.

        Args:
            hd_path_enc_bytes (bytes): Encrypted HD path bytes
            hd_path_key_bytes (bytes): HD path key bytes

        Returns:
            Bip32Path object: Bip32Path object

        Raises:
            ValueError: If the decryption fails
        """
        ...
    
    @staticmethod
    def SplitDecodedBytes(dec_bytes: bytes) -> Tuple[bytes, bytes]:
        """
        Split the decoded bytes into address root hash and encrypted HD path.

        Args:
            dec_bytes (bytes): Decoded bytes

        Returns:
            tuple[bytes, bytes]: Address root hash (index 0), encrypted HD path (index 1)
        """
        ...
    
    @staticmethod
    def DecodeAddr(addr: str, **kwargs: Any) -> bytes:
        """
        Decode a Cardano Byron address (either legacy or Icarus) to bytes.
        The result can be split with SplitDecodedBytes if needed, to get the address root hash and
        encrypted HD path separately.

        Args:
            addr (str): Address string

        Other Parameters:
            addr_type (AdaByronAddrTypes): Expected address type (default: public key)

        Returns:
            bytes: Address root hash bytes (first 28-byte) and encrypted HD path (following bytes, if present)

        Raises:
            ValueError: If the address encoding is not valid
            TypeError: If the address type is not a AdaByronAddrTypes enum
        """
        ...
    


class AdaByronIcarusAddrEncoder(IAddrEncoder):
    """
    Cardano Byron Icarus address encoder class.
    It allows the Cardano Byron Icarus address encoding (i.e. without the encrypted derivation path, format Ae2...).
    """
    @staticmethod
    def EncodeKey(pub_key: Union[bytes, IPublicKey], **kwargs: Any) -> str:
        """
        Encode a public key to Cardano Byron address.

        Args:
            pub_key (bytes or IPublicKey): Public key bytes or object

        Other Parameters:
            chain_code (bytes or Bip32ChainCode object): Chain code bytes or object

        Returns:
            str: Address string

        Raises:
            Bip32PathError: If the path indexes are not valid
            ValueError: If the public key, the chain code or the HD path key is not valid
            TypeError: If the public key is not ed25519
        """
        ...
    


class AdaByronLegacyAddrEncoder(IAddrEncoder):
    """
    Cardano Byron legacy address encoder class.
    It allows the Cardano Byron legacy address encoding (i.e. containing the encrypted derivation path, format Ddz...).
    """
    @staticmethod
    def EncodeKey(pub_key: Union[bytes, IPublicKey], **kwargs: Any) -> str:
        """
        Encode a public key to Cardano Byron address.

        Args:
            pub_key (bytes or IPublicKey): Public key bytes or object

        Other Parameters:
            chain_code (bytes or Bip32ChainCode object): Chain code bytes or object
            hd_path (str or Bip32Path object)          : HD path
            hd_path_key (bytes)                        : HD path key bytes, shall be 32-byte long

        Returns:
            str: Address string

        Raises:
            Bip32PathError: If the path indexes are not valid
            ValueError: If the public key, the chain code or the HD path key is not valid
            TypeError: If the public key is not ed25519
        """
        ...
    


AdaByronIcarusAddr = AdaByronIcarusAddrEncoder
AdaByronLegacyAddr = AdaByronLegacyAddrEncoder
