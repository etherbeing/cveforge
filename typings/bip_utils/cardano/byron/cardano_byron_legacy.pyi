"""
This type stub file was generated by pyright.
"""

from functools import lru_cache
from typing import Union
from bip_utils.bip.bip32 import Bip32Base, Bip32KeyIndex, Bip32Path, Bip32PrivateKey, Bip32PublicKey

"""Module for Cardano Byron legacy keys derivation."""
class CardanoByronLegacyConst:
    """Class container for Cardano Byron legacy constants."""
    HD_PATH_KEY_PBKDF2_SALT: str = ...
    HD_PATH_KEY_PBKDF2_ROUNDS: int = ...
    HD_PATH_KEY_PBKDF2_OUT_BYTE_LEN: int = ...


class CardanoByronLegacy:
    """
    Cardano Byron legacy class.
    It allows master key generation, children keys derivation and addresses computation like the old Daedalus wallet.
    Addresses are in the Ddz... format, which contains the encrypted derivation path.
    """
    m_bip32_obj: Bip32Base
    @classmethod
    def FromSeed(cls, seed_bytes: bytes) -> CardanoByronLegacy:
        """
        Construct class from seed bytes.

        Args:
            seed_bytes (bytes): Seed bytes

        Returns:
            CardanoByronLegacy object: CardanoByronLegacy object
        """
        ...
    
    def __init__(self, bip32_obj: Bip32Base) -> None:
        """
        Construct class.

        Args:
            bip32_obj (Bip32Base object): Bip32Base object

        Raises:
            ValueError: If the bip32 object is not a master key
            TypeError: If the bip32 object is not a CardanoByronLegacyBip32 class instance
        """
        ...
    
    def Bip32Object(self) -> Bip32Base:
        """
        Return the BIP32 object.

        Returns:
            Bip32Base object: Bip32Base object
        """
        ...
    
    @lru_cache()
    def HdPathKey(self) -> bytes:
        """
        Get the key used for HD path decryption/encryption.

        Returns:
            bytes: Key bytes
        """
        ...
    
    def HdPathFromAddress(self, address: str) -> Bip32Path:
        """
        Get the HD path from an address by decrypting it.
        The address shall be derived from the current object master key (i.e. self.m_bip32_obj) in order to
        successfully decrypt the path.

        Args:
            address (str): Address string

        Returns:
            Bip32Path object: Bip32Path object

        Raises:
            ValueError: If the address encoding is not valid or the path cannot be decrypted
        """
        ...
    
    def MasterPrivateKey(self) -> Bip32PrivateKey:
        """
        Get the master private key.

        Returns:
            Bip32PrivateKey object: Bip32PrivateKey object
        """
        ...
    
    def MasterPublicKey(self) -> Bip32PublicKey:
        """
        Get the master public key.

        Returns:
            Bip32PublicKey object: Bip32PublicKey object
        """
        ...
    
    def GetPrivateKey(self, first_idx: Union[int, Bip32KeyIndex], second_idx: Union[int, Bip32KeyIndex]) -> Bip32PrivateKey:
        """
        Get the private key with the specified indexes.
        Derivation path: m/first_idx'/second_idx'
        The indexes will be automatically hardened if not (e.g. 0, 1' -> 0', 1').

        Args:
            first_idx (int or Bip32KeyIndex object) : First index
            second_idx (int or Bip32KeyIndex object): Second index

        Returns:
            IPrivateKey object: IPrivateKey object

        Raises:
            Bip32KeyError: If the derivation results in an invalid key
            Bip32PathError: If the path indexes are not valid
        """
        ...
    
    def GetPublicKey(self, first_idx: Union[int, Bip32KeyIndex], second_idx: Union[int, Bip32KeyIndex]) -> Bip32PublicKey:
        """
        Get the public key with the specified indexes.
        Derivation path: m/first_idx'/second_idx'
        The indexes will be automatically hardened if not (e.g. 0, 1' -> 0', 1').


        Args:
            first_idx (int or Bip32KeyIndex object) : First index
            second_idx (int or Bip32KeyIndex object): Second index

        Returns:
            IPublicKey object: IPublicKey object

        Raises:
            Bip32KeyError: If the derivation results in an invalid key
            Bip32PathError: If the path indexes are not valid
        """
        ...
    
    @lru_cache()
    def GetAddress(self, first_idx: Union[int, Bip32KeyIndex], second_idx: Union[int, Bip32KeyIndex]) -> str:
        """
        Get the address with the specified indexes.
        Derivation path: m/first_idx'/second_idx'
        The indexes will be automatically hardened if not (e.g. 0, 1' -> 0', 1').

        Args:
            first_idx (int or Bip32KeyIndex object) : First index
            second_idx (int or Bip32KeyIndex object): Second index

        Returns:
            str: Address

        Raises:
            Bip32KeyError: If the derivation results in an invalid key
            Bip32PathError: If the path indexes are not valid
        """
        ...
    


