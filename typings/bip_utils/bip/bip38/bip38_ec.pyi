"""
This type stub file was generated by pyright.
"""

from typing import Optional, Tuple
from bip_utils.bip.bip38.bip38_addr import Bip38PubKeyModes

"""
Module for BIP38 encryption/decryption.
Reference: https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki
"""
class Bip38EcConst:
    """Class container for BIP38 EC constants."""
    LOT_NUM_MIN_VAL: int = ...
    LOT_NUM_MAX_VAL: int = ...
    SEQ_NUM_MIN_VAL: int = ...
    SEQ_NUM_MAX_VAL: int = ...
    OWNER_SALT_WITH_LOT_SEQ_BYTE_LEN: int = ...
    OWNER_SALT_NO_LOT_SEQ_BYTE_LEN: int = ...
    INT_PASS_ENC_BYTE_LEN: int = ...
    INT_PASS_MAGIC_WITH_LOT_SEQ = ...
    INT_PASS_MAGIC_NO_LOT_SEQ = ...
    SEED_B_BYTE_LEN: int = ...
    ENC_BYTE_LEN: int = ...
    ENC_KEY_PREFIX: bytes = ...
    FLAG_BIT_COMPRESSED: int = ...
    FLAG_BIT_LOT_SEQ: int = ...
    SCRYPT_PREFACTOR_KEY_LEN: int = ...
    SCRYPT_PREFACTOR_N: int = ...
    SCRYPT_PREFACTOR_P: int = ...
    SCRYPT_PREFACTOR_R: int = ...
    SCRYPT_HALVES_KEY_LEN: int = ...
    SCRYPT_HALVES_N: int = ...
    SCRYPT_HALVES_P: int = ...
    SCRYPT_HALVES_R: int = ...


class _Bip38EcUtils:
    """Class container for BIP38 EC utility functions."""
    @staticmethod
    def OwnerEntropyWithLotSeq(lot_num: int, sequence_num: int) -> bytes:
        """
        Compute the owner entropy as specified in BIP38 (with EC multiplication) with lot and sequence numbers.

        Args:
            lot_num (int)     : Lot number
            sequence_num (int): Sequence number

        Returns:
            bytes: Owner entropy

        Raises:
            ValueError: If lot or sequence number is not valid
        """
        ...
    
    @staticmethod
    def OwnerEntropyNoLotSeq() -> bytes:
        """
        Compute the owner entropy as specified in BIP38 (with EC multiplication) without lot and sequence numbers.

        Returns:
            bytes: Owner entropy
        """
        ...
    
    @staticmethod
    def OwnerSaltFromEntropy(owner_entropy: bytes, has_lot_seq: bool) -> bytes:
        """
        Get owner salt from owner entropy.

        Args:
            owner_entropy (bytes): Owner entropy
            has_lot_seq (bool)   : True if lot and sequence numbers are present, false otherwise

        Returns:
            bytes: Owner salt
        """
        ...
    
    @staticmethod
    def PassFactor(passphrase: str, owner_entropy: bytes, has_lot_seq: bool) -> bytes:
        """
        Compute the passfactor as specified in BIP38 (with EC multiplication).

        Args:
            passphrase (str)     : Passphrase
            owner_entropy (bytes): Owner entropy
            has_lot_seq (bool)   : True if lot and sequence numbers are present, false otherwise

        Returns:
            bytes: Passfactor
        """
        ...
    
    @staticmethod
    def PassPoint(passfactor: bytes) -> bytes:
        """
        Compute the passpoint as specified in BIP38 (with EC multiplication).

        Args:
            passfactor (bytes): Passfactor

        Returns:
            bytes: Passpoint bytes in compressed format
        """
        ...
    
    @staticmethod
    def DeriveKeyHalves(passpoint: bytes, address_hash: bytes, owner_entropy: bytes) -> Tuple[bytes, bytes]:
        """
        Compute the scrypt as specified in BIP38 (without EC multiplication)and derive the two key halves.

        Args:
            passpoint (bytes)    : Passpoint
            address_hash (bytes) : Address hash
            owner_entropy (bytes): Owner entropy

        Returns:
            tuple[bytes, bytes]: Derived key halves
        """
        ...
    


class Bip38EcKeysGenerator:
    """
    BIP38 keys generator class.
    It generates intermediate codes and private keys using the algorithm specified in BIP38 with EC multiplication.
    """
    @staticmethod
    def GenerateIntermediatePassphrase(passphrase: str, lot_num: Optional[int] = ..., sequence_num: Optional[int] = ...) -> str:
        """
        Generate an intermediate passphrase from the user passphrase as specified in BIP38.

        Args:
            passphrase (str)            : Passphrase
            lot_num (int, optional)     : Lot number
            sequence_num (int, optional): Sequence number

        Returns:
            str: Intermediate passphrase encoded in base58
        """
        ...
    
    @staticmethod
    def GeneratePrivateKey(int_passphrase: str, pub_key_mode: Bip38PubKeyModes) -> str:
        """
        Generate a random encrypted private key from the intermediate passphrase.

        Args:
            int_passphrase (str)           : Intermediate passphrase
            pub_key_mode (Bip38PubKeyModes): Public key mode

        Returns:
            str: Encrypted private key

        Raises:
            Base58ChecksumError: If base58 checksum is not valid
            ValueError: If the intermediate code is not valid
        """
        ...
    


class Bip38EcDecrypter:
    """
    BIP38 decrypter class.
    It decrypts a private key using the algorithm specified in BIP38 with EC multiplication.
    """
    @staticmethod
    def Decrypt(priv_key_enc: str, passphrase: str) -> Tuple[bytes, Bip38PubKeyModes]:
        """
        Decrypt the specified private key.

        Args:
            priv_key_enc (str): Encrypted private key bytes
            passphrase (str)  : Passphrase

        Returns:
            tuple[bytes, Bip38PubKeyModes]: Decrypted private key (index 0), public key mode (index 1)

        Raises:
            Base58ChecksumError: If base58 checksum is not valid
            ValueError: If the encrypted key is not valid
        """
        ...
    


