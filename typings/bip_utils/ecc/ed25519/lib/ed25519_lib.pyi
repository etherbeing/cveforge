"""
This type stub file was generated by pyright.
"""

from typing import Tuple, Union

"""
Helper library for ed25519 point encoding/decoding, which cannot be done with pynacl APIs.
Encode/Decode operations copied from: https://github.com/warner/python-pure25519/blob/master/pure25519/basic.py
"""
_Q = ...
_L = ...
_G = ...
_G_DEC_BYTES = ...
_G_ENC_BYTES = ...
_COORD_BYTE_LEN = ...
_D = ...
_I = ...
def int_decode(int_bytes: bytes) -> int:
    """
    Decode int from bytes.

    Args:
        int_bytes (bytes): Integer bytes

    Returns:
        int: Decoded integer
    """
    ...

def int_encode(int_val: int) -> bytes:
    """
    Encode int to bytes.

    Args:
        int_val (int): Integer value

    Returns:
        bytes: Encoded integer
    """
    ...

def point_is_decoded_bytes(point_bytes: bytes) -> bool:
    """
    Get if point bytes are in decoded format.

    Args:
        point_bytes (bytes): Point bytes

    Returns:
        bool: True if in decoded format, false otherwise
    """
    ...

def point_is_encoded_bytes(point_bytes: bytes) -> bool:
    """
    Get if point bytes are in encoded format.

    Args:
        point_bytes (bytes): Point bytes

    Returns:
        bool: True if in encoded format, false otherwise
    """
    ...

def point_is_valid_bytes(point_bytes: bytes) -> bool:
    """
    Get if point bytes are valid.

    Args:
        point_bytes (bytes): Point bytes

    Returns:
        bool: True if valid, false otherwise
    """
    ...

def point_bytes_to_coord(point_bytes: bytes) -> Tuple[int, int]:
    """
    Convert point bytes to coordinates.

    Args:
        point_bytes (bytes): Point bytes

    Returns:
        tuple[int, int]: Point coordinates

    Raises:
        ValueError: If point bytes are not valid
    """
    ...

def point_coord_to_bytes(point_coord: Tuple[int, int]) -> bytes:
    """
    Convert point coordinates to bytes.

    Args:
        point_coord (tuple[int, int]): Point coordinates

    Returns:
        bytes: Point bytes
    """
    ...

def point_decode_no_check(point_bytes: bytes) -> Tuple[int, int]:
    """
    Decode point bytes to coordinates without checking if it lies on the ed25519 curve.

    Args:
        point_bytes (bytes): Point bytes

    Returns:
        tuple[int, int]: Point coordinates

    Raises:
        ValueError: If point bytes are not valid
    """
    ...

def point_decode(point_bytes: bytes) -> Tuple[int, int]:
    """
    Decode point bytes to coordinates by checking if it lies on the ed25519 curve.

    Args:
        point_bytes (bytes): Point bytes

    Returns:
        tuple[int, int]: Point coordinates

    Raises:
        ValueError: If the point bytes are not valid or the decoded point doesn't lie on the curve
    """
    ...

def point_encode(point_coord: Tuple[int, int]) -> bytes:
    """
    Encode point coordinates to bytes.

    Args:
        point_coord (tuple[int, int]): Point coordinates

    Returns:
        bytes: Point bytes
    """
    ...

def point_is_generator(point: Union[bytes, Tuple[int, int]]) -> bool:
    """
    Get if the point is the generator of the ed25519 curve.

    Args:
        point (bytes or tuple[int, int]): Point

    Returns:
        bool: True if generator, false otherwise

    Raises:
        ValueError: If point bytes are not valid
    """
    ...

def point_is_on_curve(point: Union[bytes, Tuple[int, int]]) -> bool:
    """
    Get if the point lies on the ed25519 curve.
    This method is used because nacl.bindings.crypto_core_ed25519_is_valid_point performs more strict checks,
    which results in points (i.e. public keys) that are considered not valid even if they are accepted by wallets.

    Args:
        point (bytes or tuple[int, int]): Point

    Returns:
        bool: True if it lies on the curve, false otherwise

    Raises:
        ValueError: If point bytes are not valid
    """
    ...

def point_add(point_1: Union[bytes, Tuple[int, int]], point_2: Union[bytes, Tuple[int, int]]) -> bytes:
    """
    Add two points on the ed25519 curve.

    Args:
        point_1 (bytes or tuple[int, int]): Point 1
        point_2 (bytes or tuple[int, int]): Point 2

    Returns:
        bytes: New point resulting from the addition
    """
    ...

def point_scalar_mul(scalar: Union[bytes, int], point: Union[bytes, Tuple[int, int]]) -> bytes:
    """
    Multiply a point on the ed25519 curve with a scalar.

    Args:
        scalar (bytes or int)           : Scalar
        point (bytes or tuple[int, int]): Point

    Returns:
        bytes: New point resulting from the multiplication
    """
    ...

def point_scalar_mul_base(scalar: Union[bytes, int]) -> bytes:
    """
    Multiply the base (i.e. generator) point of the ed25519 curve with a scalar.

    Args:
        scalar (bytes or int): Scalar

    Returns:
        bytes: New point resulting from the multiplication
    """
    ...

def scalar_reduce(scalar: Union[bytes, int]) -> bytes:
    """
    Convert the specified bytes to integer and return its lowest 32-bytes modulo ed25519 curve order.

    Args:
        scalar (bytes or int): Scalar

    Returns:
        bytes: Lowest 32-bytes modulo ed25519-order
    """
    ...

def scalar_is_valid(scalar: Union[bytes, int]) -> bool:
    """
    Get if the specified scalar is valid (i.e. less than the ed25519 curve order).

    Args:
        scalar (bytes or int): Scalar

    Returns:
        bool: True if lower, false otherwise
    """
    ...

