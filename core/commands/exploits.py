from collections.abc import Callable
from typing import Any, Self, TypedDict
from core.context import Context
from utils.args import ForgeParser

class ParserDict(TypedDict):
    parser: type[ForgeParser]|None
    callable: Callable[..., Any]

class ExploitParser(ForgeParser):
    _parsers: dict[str, ParserDict] = {}
    _singleton_parser_inst: Self|None = None

    # def __new__(cls, *args: Any, **kwargs: Any) -> Self:
    #     if not cls._singleton_parser_inst:
    #         cls._singleton_parser_inst = super().__new__(cls)
    #     return cls._singleton_parser_inst

    def __init__(self, *args: Any, **kwargs: Any):
        kwargs.update({"prog": "exploit"})
        super().__init__(*args, **kwargs)

    @classmethod
    def instance(cls):
        return cls._singleton_parser_inst

    @classmethod
    def register_exploit(cls, name: str, parser: type[ForgeParser]|None, callable: Callable[..., Any]) -> None:
        cls._parsers[name] = {
            "parser": parser,
            "callable": callable
        }

    @classmethod
    def get_exploit_parser(cls, name: str):
        return cls._parsers.get(name, {}).get("parser")
    
    @classmethod
    def run_exploit(cls, name: str, context: Context, option: str, **kwargs: Any):
        exploit = cls._parsers.get(name)
        if not exploit:
            raise ValueError("No exploit registered with the given name")

        if option == "run":
            exploit_callable = exploit.get("callable")
            return exploit_callable(context, **kwargs)
        elif option == "search":
            return cls.search_exploit(name)
    @classmethod
    def search_exploit(cls, name: str, ):
        return "no implemented yet"

    def setUp(self) -> None:
        subparsers = self.add_subparsers(dest="option", required=True) # this allows tcve_exploit to extend the options available
        # handle search
        subparsers.add_parser("search",)
        # handle run
        run_parser = subparsers.add_parser("run")
        run_command_parser = run_parser.add_subparsers(dest='command')
        for parser_name in self._parsers:
            parser_value = self._parsers[parser_name]
            argument_parser = parser_value.get("parser")
            option_parser = run_command_parser.add_parser(
                name=parser_name,
            )
            if argument_parser:
                parser = argument_parser()
                parser.setUp()
                # option_parser._actions = parser._actions # Hack a Tom :-) this should have a more human like way of doing it xD but let's just have a party for this one
                
                option_parser.__dict__.update(**parser.__dict__)